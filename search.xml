<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[先序和中序确定二叉树]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[先序和中序确定二叉树 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 {1,2,4,7,3,5,6,8} 和中序遍历序列 {4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123; public: TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; // l1, h1 为先序序列的第一个和最后一个结点下标，l2, h2 为中序序列的第一个和最后一个结点下标 // 初始调用时，l1 = l2 = 0，h1 = h2 = size() - 1 int l1 = 0, h1 = pre.size() - 1, l2 = 0, h2 = vin.size() - 1; TreeNode* root = reConstructBinaryTree_recursion(pre, l1, h1, vin, l2, h2); return root; &#125; TreeNode* reConstructBinaryTree_recursion(vector&lt;int&gt; pre, int l1, int h1, vector&lt;int&gt; vin, int l2, int h2) &#123; TreeNode* root = new TreeNode(pre[l1]); // 根节点 int i = l2, llen, rlen; while (vin[i] != pre[l1])&#123; ++i; &#125; // 根节点在中序序列中位置 llen = i - l2; // 左子树长度 rlen = h2 - i; // 右子树长度 if (llen)&#123; root-&gt;left = reConstructBinaryTree_recursion(pre, l1 + 1, l1 + llen, vin, l2, l2 + llen - 1); &#125; // 递归建立左子树 else&#123; root-&gt;left = NULL; &#125; // 左子树为空 if (rlen)&#123; root-&gt;right = reConstructBinaryTree_recursion(pre, h1 - rlen + 1 , h1, vin, h2 - rlen + 1, h2); &#125; // 递归建立右子树 else&#123; root-&gt;right = NULL; &#125; // 右子树为空 return root; // 返回根节点指针 &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算日期差]]></title>
    <url>%2F2019%2F02%2F23%2F%E8%AE%A1%E7%AE%97%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[计算任意两个日期差 题目描述有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天 输入： 有多组数据，每组数据有两行，分别表示两个日期，形式为 YYYYMMDD 输出： 每组数据输出一行，即日期差值 样例输入： 2011041220110422 样例输出： 11 解题方法该题目是求两个日期间的天数差，即求分别以两个特定日期为界的日期区间的长度。解决这类区间问题有一个统一的思想——把原区间问题统一到起点确定的区间问题上去。采用预处理手段，即在程序真正开始处理输入数据之前，预处理出所有日期与原点日期之间的天数差并保存起来。再者，预处理也是空间换时间的重要手段（保存预处理所得数据所需的内存来换取实时处理所需要的时间消耗）日期类问题有个需要注意的要点——闰年，闰年并不严格按照四年一次的规律出现，在某种情况下也可能出现两个相邻闰年相隔8年的情况（如1896年与1904年）。即应采用该如下代码表示： 1#define ISYEAP(X) X%100 != 0 &amp;&amp; X%4 == 0 || X%400 == 0 ? 1:0 当需要开辟大量内存空间的情况，必须在函数体外定义，即定义全局变量，或者在函数中使用malloc等函数动态申请变量空间。即下面的代码中的buf[5001][13][32]在保存某个特定日期与原点日期的天数差时，使用了三维数组，用年、月、日分别表示该数组下标，便将日期本身与其存储地址联系起来，通过利用它的年月日数字即可找到我们保存的值，即Hash的基本思想。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;cmath&gt;#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0//定义宏判断是否是闰年int dayOfMonth[13][2] = &#123; 0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;; // 预存每月的天数，二月配合宏定义做特殊处理struct Date &#123; int Day; int Month; int Year; void nextDay() &#123; // 计算下一天的日期 ++Day; if (Day &gt; dayOfMonth[Month][ISYEAP(Year)]) &#123; // 若日数超过了当月最大日数 Day = 1; ++Month; if (Month &gt; 12) &#123; // 若月份超过 12 Month = 1; ++Year; &#125; &#125; &#125;&#125;;int buf[5001][13][32]; // 保存预处理的天数int main() &#123; Date tmp; int cnt = 0; tmp.Day = 0; tmp.Month = 0; tmp.Year = 0; while (tmp.Year != 5001) &#123; buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay(); ++cnt; &#125; int d1, m1, y1; int d2, m2, y2; while (scanf("%4d%2d%2d", &amp;y1, &amp;m1, &amp;d1) != EOF) &#123; scanf("%4d%2d%2d", &amp;y2, &amp;m2, &amp;d2); printf("%d\n", abs(buf[y1][m1][d1] - buf[y2][m2][d2]) + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python [1, -1][x == 0] 写法解释和用处]]></title>
    <url>%2F2019%2F02%2F03%2FPython%20%5B1%2C%20-1%5D%5Bx%20%3D%3D%200%5D%20%E5%86%99%E6%B3%95%E8%A7%A3%E9%87%8A%E5%92%8C%E7%94%A8%E5%A4%84%2F</url>
    <content type="text"><![CDATA[Python [1, -1][x == 0] 写法解释和用处 解释这种写法通俗形式为 [条件为假, 条件为真][判断条件]在 Python 中，布尔型 True 转变为整数等于 1，False 转变为整数等于 0所以条件为真时，返回第二个数，条件为假时，返回第一个数 用处1234if x == 0: a = -1else: a = 1 可以写成这样的形式1a = [1, -1][x == 0]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树非递归遍历]]></title>
    <url>%2F2019%2F02%2F01%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树非递归遍历 二叉树定义1234typedef struct BiTNode&#123; ElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 先序遍历12345678910111213141516void PreOrder(BiTree T)&#123; InitStack(S); BiTNode *p; p = T; while(p || isEmpty(s))&#123; if(p)&#123; Push(S, p); visit(p); p = p-&gt;lchild; &#125; else&#123; Pop(S, p); p = p-&gt;rchild; &#125; &#125;&#125; 中序遍历12345678910111213141516void InOrder(BiTree T)&#123; InitStack(S); BiTNode *p; p = T; while(p || isEmpty(s))&#123; if(p)&#123; Push(S, p); p = p-&gt;lchild; &#125; else&#123; Pop(S, p); visit(p); p = p-&gt;rchild; &#125; &#125;&#125; 后序遍历1234567891011121314151617181920212223242526void PostOrder(BiTree T)&#123; InitStack(S); BiTNode *p; p = T; r = NULL; while(p || isEmpty(s))&#123; if(p)&#123; Push(S, p); p = p-&gt;lchild; &#125; else&#123; GetTop(S, p); if(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)&#123; p = p-&gt;rchild; Push(S, p); p = p-&gt;lchild; &#125; else&#123; Pop(S, p); visit(p); r = p; p = NULL; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>DS，二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的反转]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[单链表的反转 链表的定义1234typedef struct LinkNode&#123; int val; struct LinkNode *next;&#125; LinkNode; 非递归写法123456789101112131415161718LinkNode* Reverse(LinkNode *head)&#123; if(head == NULL || head-&gt;next == NULL)&#123; return head; &#125; LinkNode* pre = head; LinkNode* cur = head-&gt;next; LinkNode* temp = head-&gt;next-&gt;next; while(cur)&#123; temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; head-&gt;next = NULL; return pre;&#125; 递归写法1234567891011LinkNode* Re_Reverse(LinkNode* head)&#123; if (head == NULL || head-&gt;next == NULL)&#123; return head; &#125; LinkNode* newHead = Re_Reverse(head-&gt;next); //一直循环到链尾 head-&gt;next-&gt;next = head; //翻转链表的指向 head-&gt;next = NULL; //记得赋值NULL，防止链表错乱 return newHead; //新链表头永远指向的是原链表的链尾&#125;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>DS，剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序递归及非递归实现]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[快速排序递归及非递归实现 递归1234567891011121314151617181920212223void QuickSort(int A[], int low, int high)&#123; if(low &lt; high)&#123; int pivotpos = Partition(A, low, high); QuickSort(A, low, pivotpos - 1); QuickSort(A, pivotpos + 1, high); &#125;&#125;int Partition(int A [], int low, int high)&#123; int pivot = A[low]; while(low &lt; high)&#123; while(low &lt; high &amp;&amp; A[high] &gt;= pivot)&#123; --high; &#125; A[low] = A[high]; while(low &lt; high &amp;&amp; A [low] &gt;= pivot)&#123; ++low; &#125; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125; 非递归12345678910111213141516171819202122232425262728293031323334353637383940414243void QuickSort(int *array, int left, int right)&#123; stack&lt;int&gt; s; s.push(left); s.push(right); //后入的right，所以要先拿right //其实就是用栈保存每一个待排序子串的首尾元素下标，下一次while循环时取出这个范围，对这段子序列进行partition操作 while(!s.empty)&#123; int right = s.top(); s.pop(); int left = s.top(); s.pop(); int index = Partition(array, left, right); if(index-1 &gt; left)&#123; s.push(left); s.push(index - 1); &#125; if(index+1 &lt; right)&#123; s.push(index + 1); s.push(right); &#125; &#125;&#125;int PartSort(int* array,int left,int right)&#123; int key = array[right]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; array[left] &lt;= key) &#123; ++left; &#125; array[right] = array[left]; while(left &lt; right &amp;&amp; array[right] &gt;= key) &#123; --right; &#125; array[left] = array[right]; &#125; array[right] = key; return right;&#125;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的os.path.dirname(__file__)的使用]]></title>
    <url>%2F2017%2F07%2F02%2FPython%E4%B8%AD%E7%9A%84os.path.dirname(__file__)%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python中的os.path.dirname(__file__)的使用 1. 必须是实际存在的.py文件，如果在命令行执行，则会引发异常1NameError: name &apos;__file__&apos; is not defined 2. 返回的路径在运行的时候如果输入完整的执行的路径 1yxd@yxd-virtual-machine:~/venv$ python /home/yxd/venv/test/test.py 则返回.py文件的全路路径 1/home/yxd/venv/test 如果是非完整路径且不在本目录下执行 1yxd@yxd-virtual-machine:~/venv$ python test/test.py 则返回命令行输入的文件所在路径前面部分 1test 如果是在本目录下运行 1yxd@yxd-virtual-machine:~/venv/test$ python test.py 则返回空 3. 结合os.path.abspath用，效果会更好Python项目的代码中，经常有这样的组合os.path.dirname(os.path.abspath(__file__))或os.path.abspath(os.path.dirname(__file__)) os.path.abspath(file)返回的是.py文件的绝对路径 4. os.path.dirname(__file__)的用法总结 不要已命令行的形式使用os.path.dirname(__file__) 结合os.path.abspath()使用]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python日期格式，时间戳之间转换]]></title>
    <url>%2F2017%2F07%2F01%2FPython%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%EF%BC%8C%E6%97%B6%E9%97%B4%E6%88%B3%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Python日期格式，时间戳之间转换 获取当前时间戳 方法： 12345import timenow = time.time()print(&apos;now:&apos;, now, &apos;\n&apos;, type(now)) 输出结果： 12now: 1498926743.1411922 &lt;class &apos;float&apos;&gt; 获取当前日期 方法： 12345import datetimedatenow = datetime.datetime.now()print(&apos;datenow:&apos;, datenow, &apos;\n&apos;, type(datenow)) 输出结果： 12datenow: 2017-07-02 00:34:35.272749 &lt;class &apos;datetime.datetime&apos;&gt; 字符串格式更改如a = “2017-07-02 00:34:35”，想改为 a = “2017/07/02 00:34:35” 方法： 1234567import timea = &quot;2013-10-10 23:40:00&quot;timeArray = time.strptime(a, &quot;%Y-%m-%d %H:%M:%S&quot;) # 先转换为时间数组otherStyleTime = time.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;, timeArray) # 转换为其他格式print(&apos;otherStyleTime:&apos;, otherStyleTime) 输出结果： 1otherStyleTime: 2017/07/02 00:34:35 将字符串的时间转换为时间戳 方法： 1234567import timea = &quot;2017-07-02 00:34:35&quot; timeArray = time.strptime(a, &quot;%Y-%m-%d %H:%M:%S&quot;) # 将其转换为时间数组timeStamp = int(time.mktime(timeArray)) # 转换为时间戳print(&apos;timesStamp:&apos;, timeStamp) 输出结果： 1timesStamp: 1498926875 时间戳转换为指定格式日期 方法一： 1234567import timetimeStamp = 1498927046timeArray = time.localtime(timeStamp) # 利用localtime()转换为时间数组otherStyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray) # 格式化为需要的格式print(&apos;otherStyleTime:&apos;, otherStyleTime) 方法二： 1234567import datetimetimeStamp = 1498927046dateArray = datetime.datetime.fromtimestamp(timeStamp)otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(&apos;otherStyleTime:&apos;, otherStyleTime) 输出结果： 1otherStyleTime: 2017-07-02 00:37:26 获取当前时间并转换为指定日期格式 方法一： 1234567import timenow = int(time.time()) # 获得当前时间时间戳timeArray = time.localtime(now)StyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray)print(&apos;StyleTime:&apos;, StyleTime) 方法二： 123456import datetimenow = datetime.datetime.now() # 获得当前时间，这是时间数组格式StyleTime = now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 转换为指定的格式print(&apos;StyleTime:&apos;, StyleTime) 输出结果： 1StyleTime: 2017-07-02 00:16:30 获得三天前的时间 方法: 12345678import timeimport datetimethreeDayAgo = (datetime.datetime.now() - datetime.timedelta(days = 3)) # 先获得时间数组格式的日期timeStamp = int(time.mktime(threeDayAgo.timetuple())) # 转换为时间戳threeDayAgo = threeDayAgo.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 转换为其他字符串格式print(&apos;threeDayAgo:&apos;, threeDayAgo) timedelta()的参数有:days, seconds, microseconds, milliseconds, minutes, hours, weeks 输出结果： 1threeDayAgo: 2017-06-29 00:21:04 给定时间戳,计算该时间的几天前时间: 方法: 1234567import datetimetimeStamp = 1498926852dateArray = datetime.datetime.fromtimestamp(timeStamp) # 先转换为datetimethreeDayAgo = dateArray - datetime.timedelta(days=3)print(&apos;threeDayAgo:&apos;, threeDayAgo) 输出结果： 1threeDayAgo: 2017-06-28 16:34:12 参考上面，可以转换为其他的任意格式]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
