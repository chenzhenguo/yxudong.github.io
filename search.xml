<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[和为 S 的两个数字]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%92%8C%E4%B8%BA%20S%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[和为 S 的两个数字 题目描述输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。 输出描述:对应每个测试案例，输出两个数，小的先输出。 解题思路 数列满足递增，设两个头尾两个指针 i 和 j； 若 array[i] + array[j] = sum，就是答案； 若 array[i] + array[j] &gt; sum，大的数向左移，j -= 1； 若 array[i] + array[j] &lt; sum，小的数向右移，i += 1； 本题最开始解法为利用数组存下所有结果，然后再比较两个数的乘积最小作为结果，但可以证明，两数距离最远的结果（找到的第一组）就是乘积最小的结果： 12345假设 x+y=C（C 是常数），求 x*y 的最小值不妨设 y&gt;=x，y-x=d&gt;=0，即 y=x+d，2x+d=C，x=(C-d)/2所以 x*y=x(x+d)=(C-d)(C+d)/4=(C^2-d^2)/4也就是 x*y 是一个关于变量 d 的二次函数，对称轴是 y 轴，开口向下d 是 &gt;=0 的，d 越大，x*y 也就越小 解题代码最初版本： 1234567891011121314151617181920212223242526272829303132class Solution &#123; public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; vector&lt;vector&lt;int&gt;&gt; result; int i = 0, j = array.size() - 1; while (i &lt; j)&#123; if ((array[i] + array[j]) &gt; sum)&#123; --j; &#125; else if ((array[i] + array[j]) &lt; sum)&#123; ++i; &#125; else&#123; vector&lt;int&gt; v = &#123;array[i], array[j]&#125;; result.push_back(v); ++i; &#125; &#125; vector&lt;int&gt; r; if (result.size() == 0)&#123; return r; &#125; r = result[0]; for (int i = 0; i &lt; result.size(); ++i)&#123; if (result[i][0] * result[i][1] &lt; r[0] * r[1])&#123; r[0] = result[i][0]; r[1] = result[i][1]; &#125; &#125; return r; &#125;&#125;; 改进代码： 123456789101112131415161718192021class Solution &#123; public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; vector&lt;int&gt; result; int i = 0, j = array.size() - 1; while (i &lt; j)&#123; if ((array[i] + array[j]) &gt; sum)&#123; --j; &#125; else if ((array[i] + array[j]) &lt; sum)&#123; ++i; &#125; else&#123; result.push_back(array[i]); result.push_back(array[j]); break; &#125; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子数组的最大和]]></title>
    <url>%2F2019%2F03%2F02%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[连续子数组的最大和 题目描述HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了：在古老的一维模式识别中，常常需要计算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？例如：{6, -3, -2, 7, -15, 1, 2, 2}，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止）。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？（子向量的长度至少是 1） 解题思路 用 total 记录累计值，maxSum 记录最大和； 对于一个数 A，若是 A 的左边累计数非负，那么加上 A 能使得值不小于 A，则认为累计值对整体和是有贡献的； 如果前几项累计值负数，则认为有害于总和，total 变为当前值。每次改变 total 后，若大于 maxSum，则 maxSum等于 total 解题代码12345678910111213141516171819class Solution &#123; public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; // 用 total 记录累计值，maxSum 记录最大和，初始值为第一个元素 int total = array[0], maxSum = array[0]; for (int i = 1; i &lt; array.size(); ++i)&#123; if (total &gt;= 0)&#123; total += array[i]; &#125; else&#123; total = array[i]; &#125; if (total &gt; maxSum)&#123; maxSum = total; &#125; &#125; return maxSum; &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中只出现一次的数字]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中只出现一次的数字 题目描述一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 解题思路 首先，位运算中异或的性质：两个相同数字异或为 0，一个数和 0 异或还是它本身； 当只有一个数出现一次时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了； 依照这个思路，我们来看两个数（我们假设是 AB）出现一次的数组。首先还是先异或，剩下的数字肯定是 A、B 异或的结果，这个结果的二进制中的 1，表现的是 A 和 B 的不同的位。我们就取最低位的 1 所在的位数，假设是第 3 位。接着把原数组分成两组，分组标准是第 3 位是否为 1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字 解题代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; // 首先对所有数依次异或 int bitResult = 0; for (int i = 0; i &lt; data.size(); ++i)&#123; bitResult ^= data[i]; ) // 找到最低位为 1 的是第几位 int index = 0; while ((bitResult &amp; 1) == 0)&#123; bitResult &gt;&gt;= 1; // 找不到的话右移一位 ++index; &#125; *num1 = 0; *num2 = 0; for (int i = 0; i &lt; data.size(); ++i)&#123; // 分组 if (isBit1(data[i], index))&#123; *num1 ^= data[i]; &#125; else&#123; *num2 ^= data[i]; &#125; &#125; &#125; // 判断第 index 位是否为 1 bool isBit1(int num, int index)&#123; return ((num &gt;&gt; index) &amp; 1) == 1; &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的后序遍历序列]]></title>
    <url>%2F2019%2F03%2F02%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[二叉搜索树的后序遍历序列 题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes,否则输出 No。假设输入的数组的任意两个数字都互不相同。 解题思路 后序遍历的序列中，最后一个数字是树的根节点 数组中前面的数字可以分为两部分：第一部分是左子树节点的值，都比根节点的值小；第二部分是右子树节点的值，都比根节点的值大 后面用递归分别判断左右两部分是否符合以上原则 解题代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if (sequence.size() == 0)&#123; return false; &#125; // 初始边界值为数组最初左右边界 int left = 0, right = sequence.size() - 1; return judge(sequence, left, right); &#125; bool judge(vector&lt;int&gt; sequence, int left, int right)&#123; if (left &gt;= right)&#123; return true; &#125; // 左边界大于等于右边界返回 true int root = sequence[right]; // 根节点 int i, j; for (i = left; i &lt; right; ++i)&#123; if (sequence[i] &gt; root)&#123; break; &#125; &#125; // 左半子树都小于根节点，寻找到右半子树起始位置 for (j = i; j &lt; right; ++j)&#123; if (sequence[j] &lt; root)&#123; return false; &#125; &#125; // 右半子树都大于根节点，否则 false // 递归处理左右子树 return judge(sequence, left, i - 1) &amp;&amp; judge(sequence, i, right - 1); &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的压入、弹出序列]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈的压入、弹出序列 题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1, 2, 3, 4, 5 是某栈的压入顺序，序列 4, 5, 3, 2, 1 是该压栈序列对应的一个弹出序列，但 4, 3, 5, 1, 2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 解题思路 模拟栈操作，将压栈序列依次压入辅助栈，每次压入栈的元素与所给弹出序列相比，如果相同则出栈，如果不同则继续压栈，直到原压栈序列中所有数字压栈完毕； 检测辅助栈中是否为空，若空，说明弹出序列可由原压栈序列进行栈操作得到。否则，说明弹出队列不能由原压栈序列进行栈操作得到 解题代码123456789101112131415class Solution &#123; public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; stack&lt;int&gt; s; int j = 0; // 设置出栈队列的起始下标 for (int i = 0; i &lt; pushV.size(); ++i)&#123; s.push(pushV[i]); while (!s.empty() &amp;&amp; s.top() == popV[j])&#123; s.pop(); ++j; &#125; &#125; return s.empty(); &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2019%2F02%2F28%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[用两个栈实现队列 题目描述用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。 解题思路 入队：直接 push 进 stack1； 出队：判断 stack2 是否为空，如果为空，则将 stack1 中所有元素 pop，并 push 进 stack2，stack2 出栈；如果不为空，stack2 直接出栈 解题代码1234567891011121314151617181920212223242526class Solution&#123; public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; if (stack2.empty())&#123; int temp; while (!stack1.empty())&#123; temp = stack1.top(); stack1.pop(); stack2.push(temp); &#125; &#125; int node; node = stack2.top(); stack2.pop(); return node; &#125; private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2; &#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺时针打印矩阵]]></title>
    <url>%2F2019%2F02%2F27%2F%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[顺时针打印矩阵 题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下 4X4 矩阵：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10. 解题思路 每次都是一个圈，所以定义四个变量限定每次循环的界限：startRow, endRow, startCol, endCol； 分别把首行，末列，末行，首列的数据依次加入 vector； 为了不重复加入元素，每次走完一圈后重新限定界限 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; vector&lt;int&gt; v; if (matrix.size() == 0)&#123; return v; &#125; if (matrix[0].size() == 0)&#123; return v; &#125; // 起始的四个界限 int startRow = 0; int endRow = matrix.size() - 1; int startCol = 0; int endCol = matrix[0].size() - 1; while(startRow &lt;= endRow &amp;&amp; startCol &lt;= endCol)&#123; // 矩阵最终可能会剩下一行或一列，如果不这么处理，会重复加入元素 // 如果就剩下一行 if(startRow == endRow)&#123; for(int i = startCol;i &lt;= endCol; ++i) v.push_back(matrix[startRow][i]); return v; &#125; // 如果就剩下一列 if(startCol == endCol)&#123; for(int i = startRow; i &lt;= endRow; ++i) v.push_back(matrix[i][startCol]); return v; &#125; // 首行 for(int i = startCol; i &lt;= endCol; ++i) v.push_back(matrix[startRow][i]); // 末列 for(int i = startRow + 1; i &lt;= endRow; ++i) v.push_back(matrix[i][endCol]); // 末行 for(int i = endCol - 1; i &gt;= startCol; --i) v.push_back(matrix[endRow][i]); // 首列 for(int i = endRow-1; i &gt;= startRow + 1; --i) v.push_back(matrix[i][startCol]); startRow = startRow + 1; endRow = endRow - 1; startCol = startCol + 1; endCol = endCol - 1; &#125; return v; &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中出现次数超过一半的数字 题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组 {1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。 思路一 题目中要找的数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多； 我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数； 当我们遍历到下一个数字的时，如果下一个数字和当前我们保存的数字相同，则次数加 1；如果和当前我们保存的数字不同，则次数减 1；当次数减到 0 的时候，我们将保存的数字改为当前遍历所处的位置，并将次数更改为 1 解题代码一123456789101112131415161718192021222324252627class Solution &#123; public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; int r = numbers[0]; int count = 1; for (int i = 1; i &lt; numbers.size(); ++i)&#123; if (count == 0)&#123; r = numbers[i]; count = 1; &#125; else if (numbers[i] == r)&#123; ++count; &#125; else &#123; --count; &#125; &#125; // 看最后一个元素个数是否超过长度一半 count = 0; for (int i = 0; i &lt; numbers.size(); ++i)&#123; if (numbers[i] == r)&#123; ++count; &#125; &#125; return count &gt; numbers.size() / 2 ? r : 0; &#125;&#125;; 思路二首先将容器中的数字排序，排序结束后，如果存在次数大于数组大小一半的数，必定在数组中间位置 解题代码二123456789101112131415class Solution &#123; public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; sort(numbers.begin(),numbers.end()); int half = numbers.size() / 2; int count = 0; for(int i = 0; i &lt; numbers.size(); ++i)&#123; if(numbers[i]==numbers[half])&#123; ++count; &#125; &#125; return count &gt; half ? numbers[half] : 0; &#125;&#125;; 思路三利用 map 把每个数字出现的次数储存起来 解题代码三12345678910111213141516171819class Solution &#123; public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; map&lt;int,int&gt; numbersMap; for(int i = 0; i &lt; numbers.size(); ++i)&#123; numbersMap[numbers[i]] += 1; &#125; int half = numbers.size() / 2; int number = 0; for(map&lt;int,int&gt;::iterator it = numbersMap.begin(); it != numbersMap.end(); ++it)&#123; if(it-&gt;second &gt; half)&#123; number = it-&gt;first; break; &#125; &#125; return number; &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求 1 + 2 + 3 + ... + n]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%B1%82%201%20%2B%202%20%2B%203%20%2B%20...%20%2B%20n%2F</url>
    <content type="text"><![CDATA[求 1 + 2 + 3 + … + n 题目描述求 1 + 2 + 3 + … + n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（ A ? B : C）。 解题思路 利用逻辑与的短路特性实现递归终止； 当 n == 0 时，(n &gt; 0) &amp;&amp; ((sum += Sum_Solution(n - 1)) &gt; 0) 只执行前面的判断，为 false，然后直接返回 0； 当 n &gt; 0 时，执行 sum += Sum_Solution(n - 1)，实现递归计算 Sum_Solution(n) 解题代码12345678class Solution &#123; public: int Sum_Solution(int n) &#123; int sum = n; (n &gt; 0) &amp;&amp; (sum += Sum_Solution(n - 1)); return sum; &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包含 min 函数的栈]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%8C%85%E5%90%AB%20min%20%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[包含 min 函数的栈 题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为 O（1））。 解题代码12345678910111213141516171819202122232425262728293031323334class Solution &#123; public: // s 为常规的栈 // smin 为保存最小值的栈，其中顶部永远为最小值 stack&lt;int&gt; s, smin; void push(int value) &#123; s.push(value); // s 正常压栈 if (smin.empty())&#123; smin.push(value); // smin 为空，直接进栈 &#125; else if (value &lt;= smin.top())&#123; smin.push(value); // 待进栈元素小于最小值时，才会进入 smin 栈 &#125; &#125; void pop() &#123; int n = s.top(); s.pop(); // s 正常弹出 if (n == smin.top())&#123; smin.pop(); // 如果弹出元素为最小值，smin 顶部也弹出 &#125; &#125; int top() &#123; // 直接返回顶部即可 return s.top(); &#125; int min() &#123; // 返回 smin 顶部 return smin.top(); &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2019%2F02%2F23%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树的深度 题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 递归解法123456789101112131415161718192021222324/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123; public: int TreeDepth(TreeNode *pRoot) &#123; if (!pRoot)&#123; return 0; // 若为空树，深度为 0 &#125; else &#123; // 采用后序遍历 int dl = TreeDepth(pRoot-&gt;left); int dr = TreeDepth(pRoot-&gt;right); return (dl &gt; dr? dl : dr) + 1; &#125; &#125;&#125;; 非递归解法1234567891011121314151617181920212223242526272829303132333435363738/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123; public: int TreeDepth(TreeNode *pRoot)&#123; if (!pRoot)&#123; return 0; &#125; queue&lt;TreeNode *&gt; q; q.push(pRoot); int level = 0; while(!q.empty())&#123; ++level; int len = q.size(); while (len &gt; 0)&#123; TreeNode *p = q.front(); q.pop(); if (p-&gt;left)&#123; q.push(p-&gt;left); &#125; if (p-&gt;right)&#123; q.push(p-&gt;right); &#125; --len; &#125; &#125; return level; &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lintcode 20. 骰子求和]]></title>
    <url>%2F2019%2F02%2F23%2FLintcode%2020.%20%E9%AA%B0%E5%AD%90%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[Lintcode 20. 骰子求和 题目描述扔 n 个骰子，向上面的数字之和为 S。给定 Given n，请列出所有可能的 S 值及其相应的概率。 样例给定 n = 1，返回 [[1, 0.17], [2, 0.17], [3, 0.17], [4, 0.17], [5, 0.17], [6, 0.17]]。 注意事项你不需要关心结果的准确性，我们会帮你输出结果。 思路递归求解，dicesSum(n)可以用dicesSum(n-1)和dicesSum(1)来求解。利用map存放向上的数字之和与概率。 解题代码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public: /** * @param n an integer * @return a list of pair&lt;sum, probability&gt; */ // 递归求骰子的概率 map&lt;int, double&gt; get_next(int n)&#123; map&lt;int, double&gt; m; for (int i = 1; i &lt;= 6; ++i)&#123; m[i] = (double)1 / 6; &#125; // m 为一次的概率 if (n == 1)&#123; return m; &#125; map&lt;int, double&gt; chance = get_next(n - 1); // 递归获取 n-1 的概率 map&lt;int, double&gt; r; for (auto i : m) &#123; for (auto c : chance) &#123; r[i.first + c.first] += i.second*c.second; // 循环遍历，相加和共 6 种情况，存在对应的 key 中 &#125; &#125; return r; &#125; vector&lt;pair&lt;int, double&gt;&gt; dicesSum(int n) &#123; vector&lt;pair&lt;int, double&gt;&gt; vec; map&lt;int, double&gt; m = get_next(n); for (auto i : m) &#123; vec.push_back(make_pair(i.first, i.second)); &#125; return vec; &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>Lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先序和中序确定二叉树]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[先序和中序确定二叉树 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 {1, 2, 4, 7, 3, 5, 6, 8} 和中序遍历序列 {4, 7, 2, 1, 5, 3, 8, 6}，则重建二叉树并返回。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: TreeNode *reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) &#123; // l1, h1 为先序序列的第一个和最后一个结点下标，l2, h2 为中序序列的第一个和最后一个结点下标 // 初始调用时，l1 = l2 = 0，h1 = h2 = size() - 1 int l1 = 0, h1 = pre.size() - 1, l2 = 0, h2 = vin.size() - 1; TreeNode *root = reConstructBinaryTree_recursion(pre, l1, h1, vin, l2, h2); return root; &#125; TreeNode *reConstructBinaryTree_recursion(vector&lt;int&gt; pre, int l1, int h1, vector&lt;int&gt; vin, int l2, int h2) &#123; TreeNode *root = new TreeNode(pre[l1]); // 根节点 int i = l2, llen, rlen; while (vin[i] != pre[l1])&#123; ++i; &#125; // 根节点在中序序列中位置 llen = i - l2; // 左子树长度 rlen = h2 - i; // 右子树长度 if (llen)&#123; root-&gt;left = reConstructBinaryTree_recursion(pre, l1 + 1, l1 + llen, vin, l2, l2 + llen - 1); &#125; // 递归建立左子树 else&#123; root-&gt;left = NULL; &#125; // 左子树为空 if (rlen)&#123; root-&gt;right = reConstructBinaryTree_recursion(pre, h1 - rlen + 1 , h1, vin, h2 - rlen + 1, h2); &#125; // 递归建立右子树 else&#123; root-&gt;right = NULL; &#125; // 右子树为空 return root; // 返回根节点指针 &#125;&#125;;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>二叉树</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算日期差]]></title>
    <url>%2F2019%2F02%2F23%2F%E8%AE%A1%E7%AE%97%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[计算任意两个日期差 题目描述有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天 输入： 有多组数据，每组数据有两行，分别表示两个日期，形式为 YYYYMMDD 输出： 每组数据输出一行，即日期差值 样例输入： 2011041220110422 样例输出： 11 解题方法该题目是求两个日期间的天数差，即求分别以两个特定日期为界的日期区间的长度。解决这类区间问题有一个统一的思想——把原区间问题统一到起点确定的区间问题上去。采用预处理手段，即在程序真正开始处理输入数据之前，预处理出所有日期与原点日期之间的天数差并保存起来。再者，预处理也是空间换时间的重要手段（保存预处理所得数据所需的内存来换取实时处理所需要的时间消耗）日期类问题有个需要注意的要点——闰年，闰年并不严格按照四年一次的规律出现，在某种情况下也可能出现两个相邻闰年相隔8年的情况（如1896年与1904年）。即应采用该如下代码表示： 1#define ISYEAP(X) X%100 != 0 &amp;&amp; X%4 == 0 || X%400 == 0 ? 1:0 当需要开辟大量内存空间的情况，必须在函数体外定义，即定义全局变量，或者在函数中使用malloc等函数动态申请变量空间。即下面的代码中的buf[5001][13][32]在保存某个特定日期与原点日期的天数差时，使用了三维数组，用年、月、日分别表示该数组下标，便将日期本身与其存储地址联系起来，通过利用它的年月日数字即可找到我们保存的值，即Hash的基本思想。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;cmath&gt;// 定义宏判断是否是闰年#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0int dayOfMonth[13][2] = &#123; 0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;; // 预存每月的天数，二月配合宏定义做特殊处理struct Date &#123; int Day; int Month; int Year; void nextDay() &#123; // 计算下一天的日期 ++Day; if (Day &gt; dayOfMonth[Month][ISYEAP(Year)]) &#123; // 若日数超过了当月最大日数 Day = 1; ++Month; if (Month &gt; 12) &#123; // 若月份超过 12 Month = 1; ++Year; &#125; &#125; &#125;&#125;;int buf[5001][13][32]; // 保存预处理的天数int main() &#123; Date tmp; int cnt = 0; tmp.Day = 0; tmp.Month = 0; tmp.Year = 0; while (tmp.Year != 5001) &#123; buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay(); ++cnt; &#125; int d1, m1, y1; int d2, m2, y2; while (scanf("%4d%2d%2d", &amp;y1, &amp;m1, &amp;d1) != EOF) &#123; scanf("%4d%2d%2d", &amp;y2, &amp;m2, &amp;d2); printf("%d\n", abs(buf[y1][m1][d1] - buf[y2][m2][d2]) + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python [1, -1][x == 0] 写法解释和用处]]></title>
    <url>%2F2019%2F02%2F03%2FPython%20%5B1%2C%20-1%5D%5Bx%20%3D%3D%200%5D%20%E5%86%99%E6%B3%95%E8%A7%A3%E9%87%8A%E5%92%8C%E7%94%A8%E5%A4%84%2F</url>
    <content type="text"><![CDATA[Python [1, -1][x == 0] 写法解释和用处 解释这种写法通俗形式为 [条件为假, 条件为真][判断条件]在 Python 中，布尔型 True 转变为整数等于 1，False 转变为整数等于 0所以条件为真时，返回第二个数，条件为假时，返回第一个数 用处1234if x == 0: a = -1else: a = 1 可以写成这样的形式1a = [1, -1][x == 0]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序递归及非递归实现]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[快速排序递归及非递归实现 递归1234567891011121314151617181920212223void QuickSort(int A[], int low, int high)&#123; if(low &lt; high)&#123; int pivotpos = Partition(A, low, high); QuickSort(A, low, pivotpos - 1); QuickSort(A, pivotpos + 1, high); &#125;&#125;int Partition(int A [], int low, int high)&#123; int pivot = A[low]; while(low &lt; high)&#123; while(low &lt; high &amp;&amp; A[high] &gt;= pivot)&#123; --high; &#125; A[low] = A[high]; while(low &lt; high &amp;&amp; A [low] &gt;= pivot)&#123; ++low; &#125; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125; 非递归12345678910111213141516171819202122232425262728293031323334353637383940414243void QuickSort(int *array, int left, int right)&#123; stack&lt;int&gt; s; s.push(left); s.push(right); // 后入的 right，所以要先拿 right // 其实就是用栈保存每一个待排序子串的首尾元素下标，下一次 while 循环时取出这个范围，对这段子序列进行 partition 操作 while(!s.empty)&#123; int right = s.top(); s.pop(); int left = s.top(); s.pop(); int index = Partition(array, left, right); if(index-1 &gt; left)&#123; s.push(left); s.push(index - 1); &#125; if(index+1 &lt; right)&#123; s.push(index + 1); s.push(right); &#125; &#125;&#125;int PartSort(int *array,int left,int right)&#123; int key = array[right]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; array[left] &lt;= key) &#123; ++left; &#125; array[right] = array[left]; while(left &lt; right &amp;&amp; array[right] &gt;= key) &#123; --right; &#125; array[left] = array[right]; &#125; array[right] = key; return right;&#125;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树非递归遍历]]></title>
    <url>%2F2019%2F02%2F01%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树非递归遍历 二叉树定义1234typedef struct BiTNode&#123; ElemType data; struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree; 先序遍历12345678910111213141516void PreOrder(BiTree T)&#123; InitStack(S); BiTNode *p; p = T; while(p || isEmpty(s))&#123; if(p)&#123; Push(S, p); visit(p); p = p-&gt;lchild; &#125; else&#123; Pop(S, p); p = p-&gt;rchild; &#125; &#125;&#125; 中序遍历12345678910111213141516void InOrder(BiTree T)&#123; InitStack(S); BiTNode *p; p = T; while(p || isEmpty(s))&#123; if(p)&#123; Push(S, p); p = p-&gt;lchild; &#125; else&#123; Pop(S, p); visit(p); p = p-&gt;rchild; &#125; &#125;&#125; 后序遍历1234567891011121314151617181920212223242526void PostOrder(BiTree T)&#123; InitStack(S); BiTNode *p; p = T; r = NULL; while(p || isEmpty(s))&#123; if(p)&#123; Push(S, p); p = p-&gt;lchild; &#125; else&#123; GetTop(S, p); if(p-&gt;rchild &amp;&amp; p-&gt;rchild != r)&#123; p = p-&gt;rchild; Push(S, p); p = p-&gt;lchild; &#125; else&#123; Pop(S, p); visit(p); r = p; p = NULL; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的反转]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[单链表的反转 链表的定义1234typedef struct LinkNode&#123; int val; struct LinkNode *next;&#125; LinkNode; 非递归写法123456789101112131415161718LinkNode *Reverse(LinkNode *head)&#123; if(head == NULL || head-&gt;next == NULL)&#123; return head; &#125; LinkNode *pre = head; LinkNode *cur = head-&gt;next; LinkNode *temp = head-&gt;next-&gt;next; while(cur)&#123; temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; head-&gt;next = NULL; return pre;&#125; 递归写法123456789101112131415LinkNode *Re_Reverse(LinkNode *head)&#123; if (head == NULL || head-&gt;next == NULL)&#123; return head; &#125; // 一直循环到链尾 LinkNode *newHead = Re_Reverse(head-&gt;next); // 翻转链表的指向 head-&gt;next-&gt;next = head; // 记得赋值 NULL，防止链表错乱 head-&gt;next = NULL; // 新链表头永远指向的是原链表的链尾 return newHead;&#125;]]></content>
      <categories>
        <category>DS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DS</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中的os.path.dirname(__file__)的使用]]></title>
    <url>%2F2017%2F07%2F02%2FPython%E4%B8%AD%E7%9A%84os.path.dirname(__file__)%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python中的os.path.dirname(__file__)的使用 1. 必须是实际存在的.py文件，如果在命令行执行，则会引发异常1NameError: name &apos;__file__&apos; is not defined 2. 返回的路径在运行的时候如果输入完整的执行的路径 1yxd@yxd-virtual-machine:~/venv$ python /home/yxd/venv/test/test.py 则返回.py文件的全路路径 1/home/yxd/venv/test 如果是非完整路径且不在本目录下执行 1yxd@yxd-virtual-machine:~/venv$ python test/test.py 则返回命令行输入的文件所在路径前面部分 1test 如果是在本目录下运行 1yxd@yxd-virtual-machine:~/venv/test$ python test.py 则返回空 3. 结合os.path.abspath用，效果会更好Python项目的代码中，经常有这样的组合os.path.dirname(os.path.abspath(__file__))或os.path.abspath(os.path.dirname(__file__)) os.path.abspath(__file__)返回的是.py文件的绝对路径 4. os.path.dirname(__file__)的用法总结 不要已命令行的形式使用os.path.dirname(__file__) 结合os.path.abspath()使用]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python日期格式，时间戳之间转换]]></title>
    <url>%2F2017%2F07%2F01%2FPython%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%EF%BC%8C%E6%97%B6%E9%97%B4%E6%88%B3%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Python日期格式，时间戳之间转换 获取当前时间戳 方法： 12345import timenow = time.time()print(&apos;now:&apos;, now, &apos;\n&apos;, type(now)) 输出结果： 12now: 1498926743.1411922 &lt;class &apos;float&apos;&gt; 获取当前日期 方法： 12345import datetimedatenow = datetime.datetime.now()print(&apos;datenow:&apos;, datenow, &apos;\n&apos;, type(datenow)) 输出结果： 12datenow: 2017-07-02 00:34:35.272749 &lt;class &apos;datetime.datetime&apos;&gt; 字符串格式更改如a = “2017-07-02 00:34:35”，想改为 a = “2017/07/02 00:34:35” 方法： 1234567import timea = &quot;2013-10-10 23:40:00&quot;timeArray = time.strptime(a, &quot;%Y-%m-%d %H:%M:%S&quot;) # 先转换为时间数组otherStyleTime = time.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;, timeArray) # 转换为其他格式print(&apos;otherStyleTime:&apos;, otherStyleTime) 输出结果： 1otherStyleTime: 2017/07/02 00:34:35 将字符串的时间转换为时间戳 方法： 1234567import timea = &quot;2017-07-02 00:34:35&quot; timeArray = time.strptime(a, &quot;%Y-%m-%d %H:%M:%S&quot;) # 将其转换为时间数组timeStamp = int(time.mktime(timeArray)) # 转换为时间戳print(&apos;timesStamp:&apos;, timeStamp) 输出结果： 1timesStamp: 1498926875 时间戳转换为指定格式日期 方法一： 1234567import timetimeStamp = 1498927046timeArray = time.localtime(timeStamp) # 利用localtime()转换为时间数组otherStyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray) # 格式化为需要的格式print(&apos;otherStyleTime:&apos;, otherStyleTime) 方法二： 1234567import datetimetimeStamp = 1498927046dateArray = datetime.datetime.fromtimestamp(timeStamp)otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(&apos;otherStyleTime:&apos;, otherStyleTime) 输出结果： 1otherStyleTime: 2017-07-02 00:37:26 获取当前时间并转换为指定日期格式 方法一： 1234567import timenow = int(time.time()) # 获得当前时间时间戳timeArray = time.localtime(now)StyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray)print(&apos;StyleTime:&apos;, StyleTime) 方法二： 123456import datetimenow = datetime.datetime.now() # 获得当前时间，这是时间数组格式StyleTime = now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 转换为指定的格式print(&apos;StyleTime:&apos;, StyleTime) 输出结果： 1StyleTime: 2017-07-02 00:16:30 获得三天前的时间 方法: 12345678import timeimport datetimethreeDayAgo = (datetime.datetime.now() - datetime.timedelta(days = 3)) # 先获得时间数组格式的日期timeStamp = int(time.mktime(threeDayAgo.timetuple())) # 转换为时间戳threeDayAgo = threeDayAgo.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 转换为其他字符串格式print(&apos;threeDayAgo:&apos;, threeDayAgo) timedelta()的参数有:days, seconds, microseconds, milliseconds, minutes, hours, weeks 输出结果： 1threeDayAgo: 2017-06-29 00:21:04 给定时间戳,计算该时间的几天前时间: 方法: 1234567import datetimetimeStamp = 1498926852dateArray = datetime.datetime.fromtimestamp(timeStamp) # 先转换为datetimethreeDayAgo = dateArray - datetime.timedelta(days=3)print(&apos;threeDayAgo:&apos;, threeDayAgo) 输出结果： 1threeDayAgo: 2017-06-28 16:34:12 参考上面，可以转换为其他的任意格式]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
