<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>极客时间 - 《Redis核心技术与实战》 学习笔记 4</title>
      <link href="/2020/09/29/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%204/"/>
      <url>/2020/09/29/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%204/</url>
      
        <content type="html"><![CDATA[<h2 id="极客时间-《Redis核心技术与实战》-学习笔记-4"><a href="#极客时间-《Redis核心技术与实战》-学习笔记-4" class="headerlink" title="极客时间 - 《Redis核心技术与实战》 学习笔记 4"></a>极客时间 - 《Redis核心技术与实战》 学习笔记 4</h2><h3 id="内存快照：宕机后，Redis如何实现快速恢复？"><a href="#内存快照：宕机后，Redis如何实现快速恢复？" class="headerlink" title="内存快照：宕机后，Redis如何实现快速恢复？"></a>内存快照：宕机后，Redis如何实现快速恢复？</h3><hr><ul><li>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</li></ul><pre style="font-size:0.9em; color:#666666;">save：在主线程中执行，会导致阻塞；bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</pre><ul><li>Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</li></ul><pre style="font-size:0.9em; color:#666666;">简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。<br>bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。<br>此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。<br>但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。<br>然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</pre><div style="text-align:center">    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%204_1.jpg" width="500"></div><br>- 如果频繁地执行全量快照，也会带来两方面的开销。<pre style="font-size:0.9em; color:#666666;">一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。<br>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。<br>虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。<br>如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</pre><ul><li>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。</li></ul><pre style="font-size:0.9em; color:#666666;">简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。<br>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。<br>而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。<br>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。</pre><div style="text-align:center">    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%204_2.jpg" width="500"></div><br>- RDB 优势在于，可以快速恢复数据库，也就是只需要把 RDB 文件直接读入内存，避免了 AOF 需要顺序、逐一重新执行操作命令带来的低效性能问题。缺点是频繁快照很耗资源<br><br>- 三点建议<pre style="font-size:0.9em; color:#666666;">1. 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；<br>2. 如果允许分钟级别的数据丢失，可以只使用 RDB；<br>3. 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客时间 - 《Redis核心技术与实战》 学习笔记 3</title>
      <link href="/2020/09/29/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203/"/>
      <url>/2020/09/29/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203/</url>
      
        <content type="html"><![CDATA[<h2 id="极客时间-《Redis核心技术与实战》-学习笔记-3"><a href="#极客时间-《Redis核心技术与实战》-学习笔记-3" class="headerlink" title="极客时间 - 《Redis核心技术与实战》 学习笔记 3"></a>极客时间 - 《Redis核心技术与实战》 学习笔记 3</h2><h3 id="AOF日志：宕机了，Redis如何避免数据丢失？"><a href="#AOF日志：宕机了，Redis如何避免数据丢失？" class="headerlink" title="AOF日志：宕机了，Redis如何避免数据丢失？"></a>AOF日志：宕机了，Redis如何避免数据丢失？</h3><hr><ul><li>Redis 的持久化主要有两大机制，即 AOF(Append Only File) 日志和 RDB(Redis DataBase) 快照。</li><li>AOF 日志是如何实现的？</li></ul><pre style="font-size:0.9em; color:#666666;">AOF 日志写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。</pre><div style="text-align:center">    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203_1.jpg" width="500"></div><br>- AOF 为什么要先执行命令再记日志呢？<pre style="font-size:0.9em; color:#666666;">传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。<br>以 Redis 收到 “set testkey testvalue” 命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3” 表示当前命令有三个部分，每部分都是由 “$+数字” 开头，后面紧跟着具体的命令、键或值。这里，“数字” 表示这部分中的命令、键或值一共有多少字节。例如，“$3 set” 表示这部分有 3 个字节，也就是 “set” 命令。<br>为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。<br>而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。<br>所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。<br>除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操作。</pre><div style="text-align:center">    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203_2.jpg" width="500"></div><br>- AOF 两个潜在的风险<pre style="font-size:0.9em; color:#666666;">首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。<br>如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。<br>其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。<br>这是因为，AOF 日志也是在<strong>主线程</strong>中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</pre><ul><li>三种写回策略</li></ul><pre style="font-size:0.9em; color:#666666;">对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选。<br><ul>  <li>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>  <li>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>  <li>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li></ul>针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。<ul>  <li>“同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；</li>  <li>“每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。</li>  <li>虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；</li></ul></pre><ul><li>三种策略的写回时机对比</li></ul><pre style="font-size:0.9em; color:#666666;">想要获得高性能，就选择 No 策略；<br>如果想要得到高可靠性保证，就选择 Always 策略；<br>如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。</pre><div style="text-align:center">    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203_3.jpg" width="500"></div><br>-  AOF 文件过大带来的性能问题<pre style="font-size:0.9em; color:#666666;">这里的“性能问题”，主要在于以下三个方面：<br>  一是，文件系统本身对文件大小有限制，无法保存过大的文件；<br>  二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；<br>  三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，        如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</pre><ul><li>AOF 重写机制</li></ul><pre style="font-size:0.9em; color:#666666;">AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。<br>具体的实现是：检查当前键值数据库中的键值对，记录键值对的最终状态，从而实现对某个键值对 重复操作后产生的多条操作记录压缩成一条的效果。进而实现压缩AOF文件的大小。</pre><div style="text-align:center">    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203_4.jpg" width="500"></div><br>- AOF 重写会阻塞吗?<pre style="font-size:0.9em; color:#666666;">和 AOF 日志由主线程写回不同，重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。<br></pre><ul><li>AOF 重写过程</li></ul><p><pre style="font-size:0.9em; color:#666666;"><br>重写的过程总结为“一个拷贝，两处日志”。<br><br>一个拷贝：<br>    每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。<br><br>    此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。<br><br>    然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。<br><br>两处日志：<br>    因为主线程未阻塞，仍然可以处理新来的操作。<br><br>    此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。<br>    这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。<br><br>    而第二处日志，<br>    就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。<br>    这样，重写日志也不会丢失最新的操作。<br>    等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。<br><br>    此时，我们就可以用新的 AOF 文件替代旧文件了。</pre></p><p>总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；<br>然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。<br>而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。<br></p><p><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203_5.jpg" width="500"><br></div><br></p><ul><li>对于开启 HugePages 的操作系统，父进程申请内存时阻塞的概率将会大大提高，Hugepages 在实际使用 Redis 并需要持久化时是建议关掉的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客时间 - 《Redis核心技术与实战》 学习笔记 2</title>
      <link href="/2020/09/28/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202/"/>
      <url>/2020/09/28/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202/</url>
      
        <content type="html"><![CDATA[<h2 id="极客时间-《Redis核心技术与实战》-学习笔记-2"><a href="#极客时间-《Redis核心技术与实战》-学习笔记-2" class="headerlink" title="极客时间 - 《Redis核心技术与实战》 学习笔记 2"></a>极客时间 - 《Redis核心技术与实战》 学习笔记 2</h2><h3 id="高性能IO模型：为什么单线程Redis能那么快？"><a href="#高性能IO模型：为什么单线程Redis能那么快？" class="headerlink" title="高性能IO模型：为什么单线程Redis能那么快？"></a>高性能IO模型：为什么单线程Redis能那么快？</h3><hr><ul><li>Redis 单线程的理解</li></ul><pre style="font-size:0.9em; color:#666666;">Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写（数据读写）是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。<br>但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</pre><ul><li>Redis 为什么用单线程？</li></ul><pre style="font-size:0.9em; color:#666666;">多线程编程模式面临共享资源的并发访问控制问题。<br>并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：    即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。<br>而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。<br>为了避免这些问题，Redis 直接采用了单线程模式。</pre><ul><li>单线程 Redis 为什么那么快？</li></ul><pre style="font-size:0.9em; color:#666666;">一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。<br>另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</pre><ul><li>基本 IO 模型与阻塞点</li></ul><p><pre style="font-size:0.9em; color:#666666;"><br>以 Get 请求为例，为了处理一个 Get 请求，<br>需要监听客户端请求（bind/listen），<br>和客户端建立连接（accept），<br>从 socket 中读取请求（recv），<br>解析客户端发送请求（parse），<br>根据请求类型读取键值数据（get），<br>最后给客户端返回结果，即向 socket 中写回数据（send）。<br><br>下图显示了这一过程，其中，bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作。<br>既然 Redis 是单线程，那么，最基本的一种实现是在一个线程中依次执行上面说的这些操作。</pre></p><p>但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。<br><br>当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，<br>导致其他客户端无法和 Redis 建立连接。<br><br>类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。<br></p><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202_1.jpg" width="500"><br></div><br><br><br>- 非阻塞模式<br><br><pre style="font-size:0.9em; color:#666666;"><br>在 socket 模型中，不同操作调用后会返回不同的套接字类型。<br><br>socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。<br><br>最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。<br><br>针对监听套接字，我们可以设置非阻塞模式：<br>    当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。<br>    但是，你要注意的是，调用 accept() 时，已经存在监听套接字了<br></pre><br><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202_2.jpg" width="500"><br></div><br><br><br>- 基于多路复用的高性能 I/O 模型<br><br><pre style="font-size:0.9em; color:#666666;"><br>Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。<br><br>简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。<br><br>内核会一直监听这些套接字上的连接请求或数据请求。<br><br>一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。<br><br>下图就是基于多路复用的 Redis IO 模型。<br>图中的多个 FD 就是刚才所说的多个套接字。<br><br>Redis 网络框架调用 epoll 机制，让内核监听这些套接字。<br>此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，<br>也就是说，不会阻塞在某一个特定的客户端请求处理上。<br><br>正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。<br><br>为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，<br>即针对不同事件的发生，调用相应的处理函数。<br><br>select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。<br><br>这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。<br><br>这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。<br><br>同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。<br><br>因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。<br></pre><br><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202_3.jpg" width="500"><br></div>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客时间 - 《Redis核心技术与实战》 学习笔记 1</title>
      <link href="/2020/09/28/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201/"/>
      <url>/2020/09/28/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201/</url>
      
        <content type="html"><![CDATA[<h2 id="极客时间-《Redis核心技术与实战》-学习笔记-1"><a href="#极客时间-《Redis核心技术与实战》-学习笔记-1" class="headerlink" title="极客时间 - 《Redis核心技术与实战》 学习笔记 1"></a>极客时间 - 《Redis核心技术与实战》 学习笔记 1</h2><h3 id="数据结构：快速的Redis有哪些慢操作？"><a href="#数据结构：快速的Redis有哪些慢操作？" class="headerlink" title="数据结构：快速的Redis有哪些慢操作？"></a>数据结构：快速的Redis有哪些慢操作？</h3><hr><ul><li>Redis 表现突出的原因</li></ul><pre style="font-size:0.9em; color:#666666;">一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。<br>另一方面，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</pre><ul><li>底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。</li></ul><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201_1.jpg" width="500" align="center"><br></div><br><br><br>- 键和值用什么结构组织？<br><br><pre style="font-size:0.9em; color:#666666;"><br>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。<br><br>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。<br>所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。<br><br>哈希桶中的 entry 元素中保存了 *key 和 *value 指针，分别指向了实际的键和值，<br>这样一来，即使值是一个集合，也可以通过*value指针被查找到。<br></pre><br><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201_2.jpg" width="500"><br></div><br><br><br>- 为什么哈希表操作变慢了？<br><br><pre style="font-size:0.9em; color:#666666;"><br>哈希表的冲突问题和 rehash 可能带来的操作阻塞。<br><br>Redis 解决哈希冲突的方式，就是链式哈希。<br><br>但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。<br><br>如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，<br>这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。<br><br>对于追求“快”的 Redis 来说，这是不太能接受的。<br><br>所以，Redis 会对哈希表做 rehash 操作。<br></pre><br><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201_3.jpg" width="500"><br></div><br><br><br>- 哈希表做 rehash<br><br><pre style="font-size:0.9em; color:#666666;"><br>rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。<br><br>其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：<br>哈希表 1 和哈希表 2。<br>一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。<br>随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：<br>  1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；<br>  2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；<br>  3. 释放哈希表 1 的空间。<br><br>到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。<br><br>这个过程看似简单，但是第二步涉及大量的数据拷贝，<br>如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。<br>此时，Redis 就无法快速访问数据了。<br><br>为了避免这个问题，Redis 采用了渐进式 rehash。<br></pre><br><br>- 渐进式 rehash<br><br><pre style="font-size:0.9em; color:#666666;"><br>简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求。<br><br>每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中。<br><br>等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：<br></pre><br><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201_4.jpg" width="500"><br></div><br><br><br>- 对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。<br>- 压缩列表<br><br><pre style="font-size:0.9em; color:#666666;"><br>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。<br><br>和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；<br>压缩列表在表尾还有一个 zlend，表示列表结束。<br><br>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。<br><br>而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。<br></pre><br><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201_5.jpg" width="500"><br></div><br><br><br>- 跳表<br><br><pre style="font-size:0.9em; color:#666666;"><br>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。<br><br>具体来说，跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：<br>当数据量很大时，跳表的查找复杂度就是 O(logN)。<br></pre><br><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201_6.jpg" width="500"><br></div><br><br><br>- 数据结构的时间复杂度<br><div style="text-align:center"><br>    <img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201_7.jpg" width="500"><br></div><ul><li><p>四句口诀</p><ul><li>单元素操作是基础；</li><li>范围操作非常耗时；</li><li>统计操作通常高效；</li><li>例外情况只有几个。</li></ul></li><li><p>单元素操作</p></li></ul><pre style="font-size:0.9em; color:#666666;">是指每一种集合类型对单个数据实现的增删改查操作。<br>例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。<br>这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；<br>Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。<br>这里，有个地方你需要注意一下，集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。<br>此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。</pre><ul><li>范围操作</li></ul><pre style="font-size:0.9em; color:#666666;">是指集合类型中的遍历操作，可以返回集合中的所有数据。<br>比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。<br>这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。<br>Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。<br>这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。</pre><ul><li>统计操作</li></ul><pre style="font-size:0.9em; color:#666666;">是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。<br>这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</pre><ul><li>例外情况</li></ul><pre style="font-size:0.9em; color:#666666;">是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。<br>这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</pre><ul><li>复杂度较高的 List 类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。因此，<strong>因地制宜地使用 List 类型</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uWSGI、WSGI 和 uwsgi</title>
      <link href="/2019/08/16/uWSGI%E3%80%81WSGI%20%E5%92%8C%20uwsgi/"/>
      <url>/2019/08/16/uWSGI%E3%80%81WSGI%20%E5%92%8C%20uwsgi/</url>
      
        <content type="html"><![CDATA[<h2 id="uWSGI、WSGI-和-uwsgi"><a href="#uWSGI、WSGI-和-uwsgi" class="headerlink" title="uWSGI、WSGI 和 uwsgi"></a>uWSGI、WSGI 和 uwsgi</h2><hr><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/uWSGI%E3%80%81WSGI%20%E5%92%8C%20uwsgi_1.jpg" alt="image"></p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/uWSGI%E3%80%81WSGI%20%E5%92%8C%20uwsgi_2.jpg" alt="image"></p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/uWSGI%E3%80%81WSGI%20%E5%92%8C%20uwsgi_3.jpg" alt="image"></p><h4 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h4><p>wsgi server（比如 uWSGI）要和 wsgi application（比如 django ）交互，uWSGI 需要将过来的请求转给 django 处理，那么 uWSGI 和 django 的交互和调用就需要一个统一的规范，这个规范就是 WSGI。</p><p>WSGI，全称 Web Server Gateway Interface，或者 Python Web Server Gateway Interface，是为 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。自从 WSGI 被开发出来以后，许多其它语言中也出现了类似接口。</p><p>WSGI 的官方定义是，the Python Web Server Gateway Interface。从名字就可以看出来，这东西是一个 Gateway，也就是网关。网关的作用就是在协议之间进行转换。</p><p>WSGI 是作为 Web 服务器与 Web 应用程序或应用框架之间的一种低级别的接口，以提升可移植 Web 应用开发的共同点。WSGI 是基于现存的 CGI 标准而设计的。</p><h4 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h4><p>uWSGI 是一个 Web 服务器，它实现了 WSGI 协议、uwsgi、http 等协议。Nginx 中 HttpUwsgiModule 的作用是与 uWSGI 服务器进行交换。</p><h4 id="uwsgi"><a href="#uwsgi" class="headerlink" title="uwsgi"></a>uwsgi</h4><p>与 WSGI 一样是一种通信协议，是 uWSGI 服务器的独占协议，用于定义传输信息的类型（type of information），每一个 uwsgi packet 前 4byte 为传输信息类型的描述，与 WSGI 协议是两种东西，据说该协议是 fcgi 协议的 10 倍快。</p><h4 id="FastCgi-协议，-uwsgi-协议与-http-协议有什么用？"><a href="#FastCgi-协议，-uwsgi-协议与-http-协议有什么用？" class="headerlink" title="FastCgi 协议， uwsgi 协议与 http 协议有什么用？"></a>FastCgi 协议， uwsgi 协议与 http 协议有什么用？</h4><p>nginx 和下游服务器交互就必须使用同一个协议，只要大家沟通好使用哪个协议，就可以正常运行了。</p><p>这三种协议就是 nginx 为了与下游服务器交互事先约定好的协议。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra 最短路径算法 Python 实现</title>
      <link href="/2019/06/27/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/06/27/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Dijkstra-最短路径算法-Python-实现"><a href="#Dijkstra-最短路径算法-Python-实现" class="headerlink" title="Dijkstra 最短路径算法 Python 实现"></a>Dijkstra 最短路径算法 Python 实现</h2><hr><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用 Dijkstra 算法求图中的任意顶点到其它顶点的最短路径（求出需要经过那些点以及最短距离）。</p><p>以下图为例：</p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0_1.png" alt="image"></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>可以使用二维数组来存储顶点之间边的关系</p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0_2.png" alt="image"></p><p>首先需要用一个一维数组 dis 来存储 初始顶点到其余各个顶点的初始路程，以求 1 顶点到其它各个顶点为例：</p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0_3.png" alt="image"></p><p>将此时 dis 数组中的值称为最短路的“估计值”。</p><p>既然是求 1 号顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离 1 号顶点最近是 2 号顶点。当选择了 2 号顶点后，dis[2] 的值就已经从“估计值”变为了“确定值”，即 1 号顶点到 2 号顶点的最短路程就是当前 dis[2]值。为什么呢？因为目前离 1 号顶点最近的是 2 号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 1 号顶点到 2 号顶点的路程进一步缩短了。</p><p>既然选了 2 号顶点，接下来再来看 2 号顶点有哪些出边。有 2-&gt;3 和 2-&gt;4 这两条边。先讨论通过 2-&gt;3 这条边能否让 1 号顶点到 3 号顶点的路程变短。也就是说现在比较 dis[3] 和 dis[2] + G[2][3]的大小。其中 dis[3] 表示 1 号顶点到 3 号顶点的路程。dis[2] + G[2][3] 中 dis[2] 表示 1 号顶点到 2 号顶点的路程，G[2][3] 表示 2-&gt;3 这条边。所以 dis[2] + G[2][3] 就表示从 1 号顶点先到 2 号顶点，再通过 2-&gt;3 这条边，到达 3 号顶点的路程。</p><a id="more"></a><p>在本例中 dis[3] = 12，dis[2] + G[2][3] = 1 + 9 = 10，dis[3] &gt; dis[2] + G[2][3]，所以 dis[3] 要更新为 10。这个过程有个专业术语叫做“松弛”。即 1 号顶点到 3 号顶点的路程即 dis[3]，通过 2-&gt;3 这条边松弛成功。这是 Dijkstra 算法的主要思想：通过“边”来松弛初始顶点到其余各个顶点的路程。</p><p>同理通过 2-&gt;4（G[2][4]），可以将 dis[4]的值从 ∞ 松弛为 4（dis[4] 初始为 ∞，dis[2] + G[2][4] = 1 + 3 = 4，dis[4] &gt; dis[2] + G[2][4]，所以 dis[4] 要更新为 4）。</p><p>刚才对 2 号顶点所有的出边进行了松弛。松弛完毕之后 dis 数组为：</p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0_4.png" alt="image"></p><p>接下来，继续在剩下的 3、4、5 和 6 号顶点中，选出离 1 号顶点最近的顶点。通过上面更新过 dis 数组，当前离 1 号顶点最近是 4 号顶点。此时，dis[4] 的值已经从“估计值”变为了“确定值”。下面继续对 4 号顶点的所有出边（4-&gt;3，4-&gt;5 和 4-&gt;6）用刚才的方法进行松弛。松弛完毕之后 dis 数组为：</p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0_5.png" alt="image"></p><p>继续在剩下的 3、5 和 6 号顶点中，选出离 1 号顶点最近的顶点，这次选择 3 号顶点。此时，dis[3] 的值已经从“估计值”变为了“确定值”。对 3 号顶点的所有出边（3-&gt;5）进行松弛。松弛完毕之后 dis 数组为：</p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0_6.png" alt="image"></p><p>继续在剩下的 5 和 6 号顶点中，选出离 1 号顶点最近的顶点，这次选择 5 号顶点。此时，dis[5] 的值已经从“估计值”变为了“确定值”。对5号顶点的所有出边（5-&gt;4）进行松弛。松弛完毕之后 dis 数组为：</p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0_7.png" alt="image"></p><p>最后对 6 号顶点所有点出边进行松弛。因为这个例子中 6 号顶点没有出边，因此不用处理。到此，dis 数组中所有的值都已经从“估计值”变为了“确定值”。</p><p>最终 dis 数组如下，这便是 1 号顶点到其余各个顶点的最短路径。</p><p><img src="https://yxd-blog.oss-cn-shanghai.aliyuncs.com/Dijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0_8.png" alt="image"></p><p>总结一下刚才的算法。算法的基本思想是：每次找到离源点（上面例子的源点就是 1 号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：</p><ol><li>将所有的顶点分为两部分：已知最短路程的顶点集合 P 和未知最短路径的顶点集合 Q。最开始，已知最短路径的顶点集合 P 中只有源点一个顶点。这里用一个 visited[ i ]数组来记录哪些点在集合 P 中。例如对于某个顶点 i，如果 visited[ i ]为 1 则表示这个顶点在集合 P 中，如果 visited[ i ]为 0 则表示这个顶点在集合 Q 中；</li><li>设置源点 s 到自己的最短路径为 0 即 dis = 0。若存在源点有能直接到达的顶点 i，则把 dis[ i ]设为 G[s][ i ]。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为 ∞；</li><li>在集合 Q 的所有顶点中选择一个离源点 s 最近的顶点  u（即 dis[u] 最小）加入到集合 P。并考察所有以点 u 为起点的边，对每一条边进行松弛操作。例如存在一条从 u 到 v 的边，那么可以通过将边 u-&gt;v 添加到尾部来拓展一条从 s 到 v 的路径，这条路径的长度是 dis[u] + G[u][v]。如果这个值比目前已知的 dis[v] 的值要小，我们可以用新值来替代当前 dis[v] 中的值；</li><li>重复第 3 步，如果集合 Q 为空，算法结束。最终 dis 数组中的值就是源点到所有顶点的最短路径</li></ol><p><strong>Dijkstra 算法不能应用于有负权重的图</strong></p><p><strong>Dijkstra 时间复杂度为 O(N<sup>2</sup>)</strong></p><h3 id="Python-实现"><a href="#Python-实现" class="headerlink" title="Python 实现"></a>Python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Dijkstra</span><span class="params">(G, start)</span>:</span></span><br><span class="line">    <span class="comment"># 输入是从 0 开始，所以起始点减 1</span></span><br><span class="line">    start = start - <span class="number">1</span></span><br><span class="line">    inf = float(<span class="string">'inf'</span>)</span><br><span class="line">    node_num = len(G)</span><br><span class="line">    <span class="comment"># visited 代表哪些顶点加入过</span></span><br><span class="line">    visited = [<span class="number">0</span>] * node_num</span><br><span class="line">    <span class="comment"># 初始顶点到其余顶点的距离</span></span><br><span class="line">    dis = &#123;node: G[start][node] <span class="keyword">for</span> node <span class="keyword">in</span> range(node_num)&#125;</span><br><span class="line">    <span class="comment"># parents 代表最终求出最短路径后，每个顶点的上一个顶点是谁，初始化为 -1，代表无上一个顶点</span></span><br><span class="line">    parents = &#123;node: <span class="number">-1</span> <span class="keyword">for</span> node <span class="keyword">in</span> range(node_num)&#125;</span><br><span class="line">    <span class="comment"># 起始点加入进 visited 数组</span></span><br><span class="line">    visited[start] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 最开始的上一个顶点为初始顶点</span></span><br><span class="line">    last_point = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(node_num - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 求出 dis 中未加入 visited 数组的最短距离和顶点</span></span><br><span class="line">        min_dis = inf</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(node_num):</span><br><span class="line">            <span class="keyword">if</span> visited[j] == <span class="number">0</span> <span class="keyword">and</span> dis[j] &lt; min_dis:</span><br><span class="line">                min_dis = dis[j]</span><br><span class="line">                <span class="comment"># 把该顶点做为下次遍历的上一个顶点</span></span><br><span class="line">                last_point = j</span><br><span class="line">        <span class="comment"># 最短顶点假加入 visited 数组</span></span><br><span class="line">        visited[last_point] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 对首次循环做特殊处理，不然在首次循环时会没法求出该点的上一个顶点</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            parents[last_point] = start + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(node_num):</span><br><span class="line">            <span class="keyword">if</span> G[last_point][k] &lt; inf <span class="keyword">and</span> dis[k] &gt; dis[last_point] + G[last_point][k]:</span><br><span class="line">                <span class="comment"># 如果有更短的路径，更新 dis 和 记录 parents</span></span><br><span class="line">                dis[k] = dis[last_point] + G[last_point][k]</span><br><span class="line">                parents[k] = last_point + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为从 0 开始，最后把顶点都加 1</span></span><br><span class="line">    <span class="keyword">return</span> &#123;key + <span class="number">1</span>: values <span class="keyword">for</span> key, values <span class="keyword">in</span> dis.items()&#125;, &#123;key + <span class="number">1</span>: values <span class="keyword">for</span> key, values <span class="keyword">in</span> parents.items()&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    inf = float(<span class="string">'inf'</span>)</span><br><span class="line">    G = [[<span class="number">0</span>, <span class="number">1</span>, <span class="number">12</span>, inf, inf, inf],</span><br><span class="line">         [inf, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>, inf, inf],</span><br><span class="line">         [inf, inf, <span class="number">0</span>, inf, <span class="number">5</span>, inf],</span><br><span class="line">         [inf, inf, <span class="number">4</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">15</span>],</span><br><span class="line">         [inf, inf, inf, inf, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">         [inf, inf, inf, inf, inf, <span class="number">0</span>]]</span><br><span class="line">    dis, parents = Dijkstra(G, <span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"dis: "</span>, dis)</span><br><span class="line">    print(<span class="string">"parents: "</span>, parents)</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dis:  &#123;<span class="number">1</span>: <span class="number">0</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">8</span>, <span class="number">4</span>: <span class="number">4</span>, <span class="number">5</span>: <span class="number">13</span>, <span class="number">6</span>: <span class="number">17</span>&#125;</span><br><span class="line">parents:  &#123;<span class="number">1</span>: <span class="number">-1</span>, <span class="number">2</span>: <span class="number">1</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">2</span>, <span class="number">5</span>: <span class="number">3</span>, <span class="number">6</span>: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>如果求 1 号顶点到 6 号顶点的最短距离，dis[6] = 17，所以最短距离为 17。</p><p>再看 parents[6] = 5，说明 6 号顶点的上一个顶点为 5，parents[5] = 3，说明 5 号顶点的上一个顶点为 3，以此类推，最终 1 号顶点到 6 号顶点的路径为 1-&gt;2-&gt;4-&gt;3-&gt;5-&gt;6。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><ul><li>其中每次找到离 1 号顶点最近的顶点的时间复杂度是 O(N)，可以用“堆”来优化，使得这一部分的时间复杂度降低到 O(logN)；</li><li>另外对于边数 M 少于 N<sup>2</sup> 的稀疏图来说（把 M 远小于 N<sup>2</sup> 的图称为稀疏图，而 M 相对较大的图称为稠密图），可以用邻接表来代替邻接矩阵，使得整个时间复杂度优化到 O((M+N)logN)。注意，在最坏的情况下 M 就是 N<sup>2</sup>，这样的话 MlogN 要比 N<sup>2</sup> 还要大。但是大多数情况下并不会有那么多边，所以 (M+N)logN 要比 N<sup>2</sup> 小很多</li></ul>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> DS&amp;A </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 14. Longest Common Prefix</title>
      <link href="/2019/03/10/LeetCode%2014.%20Longest%20Common%20Prefix/"/>
      <url>/2019/03/10/LeetCode%2014.%20Longest%20Common%20Prefix/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-14-Longest-Common-Prefix"><a href="#LeetCode-14-Longest-Common-Prefix" class="headerlink" title="LeetCode 14. Longest Common Prefix"></a>LeetCode 14. Longest Common Prefix</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>Write a function to find the longest common prefix string amongst an array of strings.<br>If there is no common prefix, return an empty string “”.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure><p>Explanation: There is no common prefix among the input strings.</p><p><strong>Note:</strong><br>All given inputs are in lowercase letters a-z.</p><a id="more"></a><h3 id="解题代码一"><a href="#解题代码一" class="headerlink" title="解题代码一"></a>解题代码一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        minl = len(min(strs, key=len))</span><br><span class="line">        s = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(minl):</span><br><span class="line">            c = strs[<span class="number">0</span>][i]</span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">                <span class="keyword">if</span> strs[j][i] != c:</span><br><span class="line">                    flag = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            s += c</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure><h3 id="解题代码二"><a href="#解题代码二" class="headerlink" title="解题代码二"></a>解题代码二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i, letter_group <span class="keyword">in</span> enumerate(zip(*strs)):</span><br><span class="line">        <span class="comment"># strs = ["flower","flow","flight"] 时</span></span><br><span class="line">        <span class="comment"># list(zip(*strs)) 为 [('f', 'f', 'f'), ('l', 'l', 'l'), ('o', 'o', 'i'), ('w', 'w', 'g')]</span></span><br><span class="line">            <span class="keyword">if</span> len(set(letter_group)) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>][:i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min(strs)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> DS&amp;A </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个链表的第一个公共结点</title>
      <link href="/2019/03/03/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/"/>
      <url>/2019/03/03/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共结点。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><a id="more"></a><ol><li>首先，如果两个链表有公共结点，那么这个结点以及之后的结点必然是一样的，因为公共结点里的 next 值是相同的；</li><li>计算出两个链表的长度差；</li><li>让长的链表先走长度差的距离，然后两链表同时向后走，直到两结点相等，就可以求出第一个公共结点</li></ol><h3 id="解题代码一"><a href="#解题代码一" class="headerlink" title="解题代码一"></a>解题代码一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">ListNode *<span class="title">FindFirstCommonNode</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = <span class="number">0</span>, len2 = <span class="number">0</span>;</span><br><span class="line">            ListNode *p1 = pHead1, *p2 = pHead2;</span><br><span class="line">            <span class="keyword">while</span> (p1) &#123;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">                ++len1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (p2) &#123;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">                ++len2;</span><br><span class="line">            &#125; <span class="comment">// 求出两个链表长度</span></span><br><span class="line">            <span class="keyword">int</span> dlen = len1 &gt; len2 ? len1 - len2 : len2 - len1;</span><br><span class="line">            p1 = len1 &gt; len2 ? pHead1 : pHead2;</span><br><span class="line">            p2 = len1 &gt; len2 ? pHead2 : pHead1;</span><br><span class="line">            <span class="keyword">while</span> (dlen) &#123;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">                --dlen;</span><br><span class="line">            &#125; <span class="comment">// 长的链表先向后走长度差的距离</span></span><br><span class="line">            <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125; <span class="comment">// 同时向后走直到相遇</span></span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><ol><li>假定 List1 长度：a+n，List2 长度：b+n, 且 a&lt;b，那么 p1  会先到链表尾部, 这时 p2 走到 a+n 位置，将 p1 换成 List2 头部；</li><li>接着 p2 再走 b+n-(a+n)=b-a 步到链表尾部，这时 p1 也走到 List2 的 b-a 位置，还差 a 步就到可能的第一个公共结点；</li><li>将 p2 换成 List1 头部，p2 走 a 步也到可能的第一个公共节点。如果恰好 p1==p2，那么 p1 就是第一个公共结点。或者 p1 和 p2 一起走 n 步到达链表尾部，两链表没有公共结点，退出循环；</li><li>a&gt;=b 同理</li></ol><h3 id="解题代码二"><a href="#解题代码二" class="headerlink" title="解题代码二"></a>解题代码二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct ListNode *next;</span></span><br><span class="line"><span class="comment">ListNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="function">ListNode *<span class="title">FindFirstCommonNode</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">            ListNode *p1 = pHead1;</span><br><span class="line">            ListNode *p2 = pHead2;</span><br><span class="line">            <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    p1 = p1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p1 = pHead2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    p2 = p2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p2 = pHead1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>和为 S 的两个数字</title>
      <link href="/2019/03/02/%E5%92%8C%E4%B8%BA%20S%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
      <url>/2019/03/02/%E5%92%8C%E4%B8%BA%20S%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="和为-S-的两个数字"><a href="#和为-S-的两个数字" class="headerlink" title="和为 S 的两个数字"></a>和为 S 的两个数字</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。</p><ul><li>输出描述:<br>对应每个测试案例，输出两个数，小的先输出。</li></ul><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>数列满足递增，设两个头尾两个指针 i 和 j；</li><li>若 array[i] + array[j] = sum，就是答案；</li><li>若 array[i] + array[j] &gt; sum，大的数向左移，j -= 1；</li><li>若 array[i] + array[j] &lt; sum，小的数向右移，i += 1；</li><li>本题最开始解法为利用数组存下所有结果，然后再比较两个数的乘积最小作为结果，但可以证明，两数距离最远的结果（找到的第一组）就是乘积最小的结果：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假设 x+y=C（C 是常数），求 x*y 的最小值</span><br><span class="line">不妨设 y&gt;=x，y-x=d&gt;=0，即 y=x+d，2x+d=C，x=(C-d)/2</span><br><span class="line">所以 x*y=x(x+d)=(C-d)(C+d)/4=(C^2-d^2)/4</span><br><span class="line">也就是 x*y 是一个关于变量 d 的二次函数，对称轴是 y 轴，开口向下</span><br><span class="line">d 是 &gt;=0 的，d 越大，x*y 也就越小</span><br></pre></td></tr></table></figure><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><p>最初版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">array</span>[i] + <span class="built_in">array</span>[j]) &gt; sum) &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">array</span>[i] + <span class="built_in">array</span>[j]) &lt; sum) &#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="built_in">array</span>[i], <span class="built_in">array</span>[j]&#125;;</span><br><span class="line">                    result.push_back(v);</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r;</span><br><span class="line">            <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">            r = result[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result[i][<span class="number">0</span>] * result[i][<span class="number">1</span>] &lt; r[<span class="number">0</span>] * r[<span class="number">1</span>]) &#123;</span><br><span class="line">                    r[<span class="number">0</span>] = result[i][<span class="number">0</span>];</span><br><span class="line">                    r[<span class="number">1</span>] = result[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改进代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindNumbersWithSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="built_in">array</span>.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="built_in">array</span>[i] + <span class="built_in">array</span>[j]) &gt; sum) &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">array</span>[i] + <span class="built_in">array</span>[j]) &lt; sum) &#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">                    result.push_back(<span class="built_in">array</span>[j]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续子数组的最大和</title>
      <link href="/2019/03/02/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2019/03/02/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了：在古老的一维模式识别中，常常需要计算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？例如：{6, -3, -2, 7, -15, 1, 2, 2}，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止）。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？（子向量的长度至少是 1）。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>用 total 记录累计值，maxSum 记录最大和；</li><li>对于一个数 A，若是 A 的左边累计数非负，那么加上 A 能使得值不小于 A，则认为累计值对整体和是有贡献的；</li><li>如果前几项累计值负数，则认为有害于总和，total 变为当前值。每次改变 total 后，若大于 maxSum，则 maxSum<br>等于 total</li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 用 total 记录累计值，maxSum 记录最大和，初始值为第一个元素</span></span><br><span class="line">            <span class="keyword">int</span> total = <span class="built_in">array</span>[<span class="number">0</span>], maxSum = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (total &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    total += <span class="built_in">array</span>[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    total = <span class="built_in">array</span>[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (total &gt; maxSum) &#123;</span><br><span class="line">                    maxSum = total;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> maxSum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中只出现一次的数字</title>
      <link href="/2019/03/02/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/03/02/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><p>首先，位运算中异或的性质：两个相同数字异或为 0，一个数和 0 异或还是它本身；</p></li><li><p>当只有一个数出现一次时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为<strong>成对儿出现的都抵消了</strong>；</p></li><li><p>依照这个思路，我们来看两个数（我们假设是 AB）出现一次的数组。首先还是先异或，剩下的数字肯定是 A、B 异或的结果，这个结果的二进制中的 1，表现的是 A 和 B 的不同的位。我们就取最低位的 1 所在的位数，假设是第 3 位。接着把原数组分成两组，分组标准是第 3 位是否为 1。如此，<strong>相同的数肯定在一个组</strong>，因为相同数字所有位都相同，而<strong>不同的数，肯定不在一组</strong>。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字</p></li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data, <span class="keyword">int</span>* num1, <span class="keyword">int</span> *num2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 首先对所有数依次异或</span></span><br><span class="line">            <span class="keyword">int</span> bitResult = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); ++i) &#123;</span><br><span class="line">                bitResult ^= data[i];</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 找到最低位为 1 的是第几位</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((bitResult &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                bitResult &gt;&gt;= <span class="number">1</span>; <span class="comment">// 找不到的话右移一位</span></span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            *num1 = <span class="number">0</span>;</span><br><span class="line">            *num2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 分组</span></span><br><span class="line">                <span class="keyword">if</span> (isBit1(data[i], index)) &#123;</span><br><span class="line">                    *num1 ^= data[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    *num2 ^= data[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断第 index 位是否为 1</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isBit1</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((num &gt;&gt; index) &amp; <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的后序遍历序列</title>
      <link href="/2019/03/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2019/03/02/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树的后序遍历序列"><a href="#二叉搜索树的后序遍历序列" class="headerlink" title="二叉搜索树的后序遍历序列"></a>二叉搜索树的后序遍历序列</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes,否则输出 No。假设输入的数组的任意两个数字都互不相同。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>后序遍历的序列中，最后一个数字是树的根节点；</li><li>数组中前面的数字可以分为两部分：第一部分是左子树节点的值，都比根节点的值小；第二部分是右子树节点的值，都比根节点的值大；</li><li>后面用递归分别判断左右两部分是否符合以上原则</li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始边界值为数组最初左右边界</span></span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = sequence.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> judge(sequence, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="comment">// 左边界大于等于右边界返回 true</span></span><br><span class="line">            <span class="keyword">int</span> root = sequence[right]; <span class="comment">// 根节点</span></span><br><span class="line">            <span class="keyword">int</span> i, j;</span><br><span class="line">            <span class="keyword">for</span> (i = left; i &lt; right; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sequence[i] &gt; root) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="comment">// 左半子树都小于根节点，寻找到右半子树起始位置</span></span><br><span class="line">            <span class="keyword">for</span> (j = i; j &lt; right; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sequence[j] &lt; root) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="comment">// 右半子树都大于根节点，否则 false</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 递归处理左右子树</span></span><br><span class="line">            <span class="keyword">return</span> judge(sequence, left, i - <span class="number">1</span>) &amp;&amp; judge(sequence, i, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈的压入、弹出序列</title>
      <link href="/2019/03/01/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2019/03/01/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1, 2, 3, 4, 5 是某栈的压入顺序，序列 4, 5, 3, 2, 1 是该压栈序列对应的一个弹出序列，但 4, 3, 5, 1, 2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>模拟栈操作，将压栈序列依次压入辅助栈，每次压入栈的元素与所给弹出序列相比，如果相同则出栈，<br>如果不同则继续压栈，直到原压栈序列中所有数字压栈完毕；</li><li>检测辅助栈中是否为空，若空，说明弹出序列可由原压栈序列进行栈操作得到。否则，说明弹出队列不能由原压栈序列进行栈操作得到</li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 设置出栈队列的起始下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushV.size(); ++i) &#123;</span><br><span class="line">                s.push(pushV[i]);</span><br><span class="line">                <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() == popV[j]) &#123;</span><br><span class="line">                    s.pop();</span><br><span class="line">                    ++j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s.empty();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用两个栈实现队列</title>
      <link href="/2019/02/28/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2019/02/28/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>入队：直接 push 进 stack1；</li><li>出队：判断 stack2 是否为空，如果为空，则将 stack1 中所有元素 pop，并 push 进 stack2，stack2 出栈；如果不为空，stack2 直接出栈</li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            stack1.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (stack2.empty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="keyword">while</span> (!stack1.empty()) &#123;</span><br><span class="line">                    temp = stack1.top();</span><br><span class="line">                    stack1.pop();</span><br><span class="line">                    stack2.push(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> node;</span><br><span class="line">            node = stack2.top();</span><br><span class="line">            stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>顺时针打印矩阵</title>
      <link href="/2019/02/27/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/02/27/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下 4X4 矩阵：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10。</p><a id="more"></a><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>每次都是一个圈，所以定义四个变量限定每次循环的界限：startRow, endRow, startCol, endCol；</li><li>分别把首行，末列，末行，首列的数据依次加入 vector；</li><li>为了不重复加入元素，每次走完一圈后重新限定界限</li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">            <span class="keyword">if</span> (matrix.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>].size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 起始的四个界限</span></span><br><span class="line">            <span class="keyword">int</span> startRow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> endRow = matrix.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> startCol = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> endCol = matrix[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (startRow &lt;= endRow &amp;&amp; startCol &lt;= endCol) &#123;</span><br><span class="line">                <span class="comment">// 矩阵最终可能会剩下一行或一列，如果不这么处理，会重复加入元素</span></span><br><span class="line">                <span class="comment">// 如果就剩下一行</span></span><br><span class="line">                <span class="keyword">if</span> (startRow == endRow) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = startCol;i &lt;= endCol; ++i) &#123;</span><br><span class="line">                        v.push_back(matrix[startRow][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果就剩下一列</span></span><br><span class="line">                <span class="keyword">if</span> (startCol == endCol) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = startRow; i &lt;= endRow; ++i) &#123;</span><br><span class="line">                        v.push_back(matrix[i][startCol]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 首行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = startCol; i &lt;= endCol; ++i) &#123;</span><br><span class="line">                    v.push_back(matrix[startRow][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 末列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = startRow + <span class="number">1</span>; i &lt;= endRow; ++i) &#123;</span><br><span class="line">                    v.push_back(matrix[i][endCol]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 末行</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endCol - <span class="number">1</span>; i &gt;= startCol; --i) &#123;</span><br><span class="line">                    v.push_back(matrix[endRow][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 首列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = endRow<span class="number">-1</span>; i &gt;= startRow + <span class="number">1</span>; --i) &#123;</span><br><span class="line">                    v.push_back(matrix[i][startCol]);</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                startRow = startRow + <span class="number">1</span>;</span><br><span class="line">                endRow = endRow - <span class="number">1</span>;</span><br><span class="line">                startCol = startCol + <span class="number">1</span>;</span><br><span class="line">                endCol = endCol - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求 1 + 2 + 3 + ... + n</title>
      <link href="/2019/02/24/%E6%B1%82%201%20+%202%20+%203%20+%20...%20+%20n/"/>
      <url>/2019/02/24/%E6%B1%82%201%20+%202%20+%203%20+%20...%20+%20n/</url>
      
        <content type="html"><![CDATA[<h2 id="求-1-2-3-…-n"><a href="#求-1-2-3-…-n" class="headerlink" title="求 1 + 2 + 3 + … + n"></a>求 1 + 2 + 3 + … + n</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>求 1 + 2 + 3 + … + n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（ A ? B : C）。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><a id="more"></a><ol><li>利用逻辑与的短路特性实现递归终止；</li><li>当 n == 0 时，(n &gt; 0) &amp;&amp; ((sum += Sum_Solution(n - 1)) &gt; 0) 只执行前面的判断，为 false，然后直接返回 0；</li><li>当 n &gt; 0 时，执行 sum += Sum_Solution(n - 1)，实现递归计算 Sum_Solution(n)</li></ol><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = n;</span><br><span class="line">            (n &gt; <span class="number">0</span>) &amp;&amp; (sum += Sum_Solution(n - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中出现次数超过一半的数字</title>
      <link href="/2019/02/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2019/02/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组 {1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。</p><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><a id="more"></a><ol><li>题目中要找的数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多；</li><li>我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数；</li><li>当我们遍历到下一个数字的时，如果下一个数字和当前我们保存的数字相同，则次数加 1；如果和当前我们保存的数字不同，则次数减 1；当次数减到 0 的时候，我们将保存的数字改为当前遍历所处的位置，并将次数更改为 1</li></ol><h3 id="解题代码一"><a href="#解题代码一" class="headerlink" title="解题代码一"></a>解题代码一</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> r = numbers[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numbers.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    r = numbers[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (numbers[i] == r) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    --count;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看最后一个元素个数是否超过长度一半</span></span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i] == r) &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count &gt; numbers.size() / <span class="number">2</span> ? r : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><p>首先将容器中的数字排序，排序结束后，如果存在次数大于数组大小一半的数，必定在数组中间位置</p><h3 id="解题代码二"><a href="#解题代码二" class="headerlink" title="解题代码二"></a>解题代码二</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">            sort(numbers.begin(),numbers.end());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> half = numbers.size() / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (numbers[i]==numbers[half]) &#123;</span><br><span class="line">                    ++count; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count &gt; half ? numbers[half] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路三"><a href="#思路三" class="headerlink" title="思路三"></a>思路三</h3><p>利用 map 把每个数字出现的次数储存起来</p><h3 id="解题代码三"><a href="#解题代码三" class="headerlink" title="解题代码三"></a>解题代码三</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numbersMap;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); ++i) &#123;</span><br><span class="line">                numbersMap[numbers[i]] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> half = numbers.size() / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = numbersMap.begin(); it != numbersMap.end(); ++it) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;second &gt; half) &#123;</span><br><span class="line">                    number = it-&gt;first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>包含 min 函数的栈</title>
      <link href="/2019/02/23/%E5%8C%85%E5%90%AB%20min%20%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2019/02/23/%E5%8C%85%E5%90%AB%20min%20%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="包含-min-函数的栈"><a href="#包含-min-函数的栈" class="headerlink" title="包含 min 函数的栈"></a>包含 min 函数的栈</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为 O（1））。</p><a id="more"></a><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// s 为常规的栈</span></span><br><span class="line">        <span class="comment">// smin 为保存最小值的栈，其中顶部永远为最小值</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s, smin; </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            s.push(value); <span class="comment">// s 正常压栈</span></span><br><span class="line">            <span class="keyword">if</span> (smin.empty()) &#123;</span><br><span class="line">                smin.push(value); <span class="comment">// smin 为空，直接进栈</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value &lt;= smin.top()) &#123;</span><br><span class="line">                smin.push(value); <span class="comment">// 待进栈元素小于最小值时，才会进入 smin 栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = s.top();</span><br><span class="line">            s.pop(); <span class="comment">// s 正常弹出</span></span><br><span class="line">            <span class="keyword">if</span> (n == smin.top()) &#123;</span><br><span class="line">                smin.pop(); <span class="comment">// 如果弹出元素为最小值，smin 顶部也弹出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接返回顶部即可</span></span><br><span class="line">            <span class="keyword">return</span> s.top();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 返回 smin 顶部</span></span><br><span class="line">            <span class="keyword">return</span> smin.top();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的深度</title>
      <link href="/2019/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/"/>
      <url>/2019/02/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><a id="more"></a><h3 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!pRoot) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 若为空树，深度为 0 </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 采用后序遍历</span></span><br><span class="line">                <span class="keyword">int</span> dl = TreeDepth(pRoot-&gt;left);</span><br><span class="line">                <span class="keyword">int</span> dr = TreeDepth(pRoot-&gt;right);</span><br><span class="line">                <span class="keyword">return</span> (dl &gt; dr? dl : dr) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">int val;</span></span><br><span class="line"><span class="comment">struct TreeNode *left;</span></span><br><span class="line"><span class="comment">struct TreeNode *right;</span></span><br><span class="line"><span class="comment">TreeNode(int x) :</span></span><br><span class="line"><span class="comment">val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!pRoot) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode *&gt; q;</span><br><span class="line">            q.push(pRoot);</span><br><span class="line">            <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                ++level;</span><br><span class="line">                <span class="keyword">int</span> len = q.size();</span><br><span class="line">                <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    TreeNode *p = q.front();</span><br><span class="line">                    q.pop();</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                        q.push(p-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                        q.push(p-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    --len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LintCode 20. 骰子求和</title>
      <link href="/2019/02/23/LintCode%2020.%20%E9%AA%B0%E5%AD%90%E6%B1%82%E5%92%8C/"/>
      <url>/2019/02/23/LintCode%2020.%20%E9%AA%B0%E5%AD%90%E6%B1%82%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LintCode-20-骰子求和"><a href="#LintCode-20-骰子求和" class="headerlink" title="LintCode 20. 骰子求和"></a>LintCode 20. 骰子求和</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>扔 n 个骰子，向上面的数字之和为 S。给定 Given n，请列出所有可能的 S 值及其相应的概率。</p><p><strong>样例</strong><br>给定 n = 1，返回 [[1, 0.17], [2, 0.17], [3, 0.17], [4, 0.17], [5, 0.17], [6, 0.17]]。</p><p><strong>注意事项</strong><br>你不需要关心结果的准确性，我们会帮你输出结果。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归求解，dicesSum(n) 可以用 dicesSum(n-1) 和 dicesSum(1) 来求解。<br>利用 map 存放向上的数字之和与概率。</p><a id="more"></a><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @param n an integer</span></span><br><span class="line"><span class="comment">         * @return a list of pair&lt;sum, probability&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 递归求骰子的概率</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; get_next(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; ++i) &#123;</span><br><span class="line">                m[i] = (<span class="keyword">double</span>)<span class="number">1</span> / <span class="number">6</span>;</span><br><span class="line">            &#125; <span class="comment">// m 为一次的概率</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; chance = get_next(n - <span class="number">1</span>); <span class="comment">// 递归获取 n-1 的概率</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; r;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : m) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> c : chance) &#123;</span><br><span class="line">                    r[i.first + c.first] += i.second*c.second; <span class="comment">// 循环遍历，相加和共 6 种情况，存在对应的 key 中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt; dicesSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt; vec;</span><br><span class="line">            <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; m = get_next(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i : m) &#123;</span><br><span class="line">                vec.push_back(make_pair(i.first, i.second));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算日期差</title>
      <link href="/2019/02/23/%E8%AE%A1%E7%AE%97%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E5%B7%AE/"/>
      <url>/2019/02/23/%E8%AE%A1%E7%AE%97%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E5%B7%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="计算任意两个日期差"><a href="#计算任意两个日期差" class="headerlink" title="计算任意两个日期差"></a>计算任意两个日期差</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天</p><p><strong>输入</strong>：</p><p>有多组数据，每组数据有两行，分别表示两个日期，形式为 YYYYMMDD</p><p><strong>输出</strong>：</p><p>每组数据输出一行，即日期差值</p><p><strong>样例输入</strong>：</p><p>20110412<br>20110422</p><p><strong>样例输出</strong>：</p><p>11</p><a id="more"></a><h3 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h3><p>该题目是求两个日期间的天数差，即求分别以两个特定日期为界的日期区间的长度。解决这类区间问题有一个统一的思想——把原区间问题统一到起点确定的区间问题上去。<br>采用预处理手段，即在程序真正开始处理输入数据之前，预处理出所有日期与原点日期之间的天数差并保存起来。再者，预处理也是空间换时间的重要手段（保存预处理所得数据所需的内存来换取实时处理所需要的时间消耗）<br>日期类问题有个需要注意的要点——闰年，闰年并不严格按照四年一次的规律出现，在某种情况下也可能出现两个相邻闰年相隔8年的情况（如1896年与1904年）。即应采用该如下代码表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ISYEAP(X) X%100 != 0 &amp;&amp; X%4 == 0 || X%400 == 0 ? 1:0</span><br></pre></td></tr></table></figure><p>当需要开辟大量内存空间的情况，必须在函数体外定义，即定义全局变量，或者在函数中使用malloc等函数动态申请变量空间。即下面的代码中的buf[5001][13][32]<br>在保存某个特定日期与原点日期的天数差时，使用了三维数组，用年、月、日分别表示该数组下标，便将日期本身与其存储地址联系起来，通过利用它的年月日数字即可找到我们保存的值，即Hash的基本思想。</p><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">// 定义宏判断是否是闰年</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dayOfMonth[<span class="number">13</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">31</span>, <span class="number">31</span>,</span><br><span class="line">    <span class="number">28</span>, <span class="number">29</span>,</span><br><span class="line">    <span class="number">31</span>, <span class="number">31</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">31</span>, <span class="number">31</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">31</span>, <span class="number">31</span>,</span><br><span class="line">    <span class="number">31</span>, <span class="number">31</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">31</span>, <span class="number">31</span>,</span><br><span class="line">    <span class="number">30</span>, <span class="number">30</span>,</span><br><span class="line">    <span class="number">31</span>, <span class="number">31</span></span><br><span class="line">&#125;; <span class="comment">// 预存每月的天数，二月配合宏定义做特殊处理</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Day;</span><br><span class="line">    <span class="keyword">int</span> Month;</span><br><span class="line">    <span class="keyword">int</span> Year;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextDay</span><span class="params">()</span> </span>&#123; <span class="comment">// 计算下一天的日期</span></span><br><span class="line">        ++Day;</span><br><span class="line">        <span class="keyword">if</span> (Day &gt; dayOfMonth[Month][ISYEAP(Year)]) &#123; <span class="comment">// 若日数超过了当月最大日数</span></span><br><span class="line">            Day = <span class="number">1</span>;</span><br><span class="line">            ++Month;</span><br><span class="line">            <span class="keyword">if</span> (Month &gt; <span class="number">12</span>) &#123; <span class="comment">// 若月份超过 12</span></span><br><span class="line">                Month = <span class="number">1</span>;</span><br><span class="line">                ++Year;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buf[<span class="number">5001</span>][<span class="number">13</span>][<span class="number">32</span>]; <span class="comment">// 保存预处理的天数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Date tmp;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    tmp.Day = <span class="number">0</span>;</span><br><span class="line">    tmp.Month = <span class="number">0</span>;</span><br><span class="line">    tmp.Year = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tmp.Year != <span class="number">5001</span>) &#123;</span><br><span class="line">        buf[tmp.Year][tmp.Month][tmp.Day] = cnt;</span><br><span class="line">        tmp.nextDay();</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d1, m1, y1;</span><br><span class="line">    <span class="keyword">int</span> d2, m2, y2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%4d%2d%2d"</span>, &amp;y1, &amp;m1, &amp;d1) != EOF) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%4d%2d%2d"</span>, &amp;y2, &amp;m2, &amp;d2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">abs</span>(buf[y1][m1][d1] - buf[y2][m2][d2]) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>先序和中序确定二叉树</title>
      <link href="/2019/02/23/%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/02/23/%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="先序和中序确定二叉树"><a href="#先序和中序确定二叉树" class="headerlink" title="先序和中序确定二叉树"></a>先序和中序确定二叉树</h2><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br>例如输入前序遍历序列 {1, 2, 4, 7, 3, 5, 6, 8} 和中序遍历序列 {4, 7, 2, 1, 5, 3, 8, 6}，则重建二叉树并返回。</p><a id="more"></a><h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function">TreeNode *<span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// l1, h1 为先序序列的第一个和最后一个结点下标，l2, h2 为中序序列的第一个和最后一个结点下标</span></span><br><span class="line">            <span class="comment">// 初始调用时，l1 = l2 = 0，h1 = h2 = size() - 1</span></span><br><span class="line">            <span class="keyword">int</span> l1 = <span class="number">0</span>, h1 = pre.size() - <span class="number">1</span>, l2 = <span class="number">0</span>, h2 = vin.size() - <span class="number">1</span>;</span><br><span class="line">            TreeNode *root = reConstructBinaryTree_recursion(pre, l1, h1, vin, l2, h2);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function">TreeNode *<span class="title">reConstructBinaryTree_recursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="keyword">int</span> l1, <span class="keyword">int</span> h1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin, <span class="keyword">int</span> l2, <span class="keyword">int</span> h2)</span> </span>&#123;</span><br><span class="line">            TreeNode *root = <span class="keyword">new</span> TreeNode(pre[l1]); <span class="comment">// 根节点</span></span><br><span class="line">            <span class="keyword">int</span> i = l2, llen, rlen;</span><br><span class="line">            <span class="keyword">while</span> (vin[i] != pre[l1]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="comment">// 根节点在中序序列中位置</span></span><br><span class="line">            llen = i - l2; <span class="comment">// 左子树长度</span></span><br><span class="line">            rlen = h2 - i; <span class="comment">// 右子树长度</span></span><br><span class="line">            <span class="keyword">if</span> (llen) &#123;</span><br><span class="line">                root-&gt;left = reConstructBinaryTree_recursion(pre, l1 + <span class="number">1</span>, l1 + llen, vin, l2, l2 + llen - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="comment">// 递归建立左子树</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="comment">// 左子树为空</span></span><br><span class="line">            <span class="keyword">if</span> (rlen) &#123;</span><br><span class="line">                root-&gt;right = reConstructBinaryTree_recursion(pre, h1 - rlen + <span class="number">1</span> , h1, vin, h2 - rlen + <span class="number">1</span>, h2);</span><br><span class="line">            &#125; <span class="comment">// 递归建立右子树</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="comment">// 右子树为空</span></span><br><span class="line">            <span class="keyword">return</span> root; <span class="comment">// 返回根节点指针</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python [1, -1][x == 0] 写法解释和用处</title>
      <link href="/2019/02/03/Python%20%5B1,%20-1%5D%5Bx%20==%200%5D%20%E5%86%99%E6%B3%95%E8%A7%A3%E9%87%8A%E5%92%8C%E7%94%A8%E5%A4%84/"/>
      <url>/2019/02/03/Python%20%5B1,%20-1%5D%5Bx%20==%200%5D%20%E5%86%99%E6%B3%95%E8%A7%A3%E9%87%8A%E5%92%8C%E7%94%A8%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-1-1-x-0-写法解释和用处"><a href="#Python-1-1-x-0-写法解释和用处" class="headerlink" title="Python [1, -1][x == 0] 写法解释和用处"></a>Python [1, -1][x == 0] 写法解释和用处</h2><hr><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>这种写法通俗形式为 <strong>[条件为假, 条件为真][判断条件]</strong><br>在 Python 中，布尔型 True 转变为整数等于 1，False 转变为整数等于 0<br>所以条件为真时，返回第二个数，条件为假时，返回第一个数</p><h3 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">    a = <span class="number">-1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以写成这样的形式<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">-1</span>][x == <span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序递归及非递归实现</title>
      <link href="/2019/02/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="快速排序递归及非递归实现"><a href="#快速排序递归及非递归实现" class="headerlink" title="快速排序递归及非递归实现"></a>快速排序递归及非递归实现</h2><hr><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = Partition(A, low, high);</span><br><span class="line">        QuickSort(A, low, pivotpos - <span class="number">1</span>);</span><br><span class="line">        QuickSort(A, pivotpos + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A [], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A [low] &lt;= pivot) &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    s.push(left);</span><br><span class="line">    s.push(right); <span class="comment">// 后入的 right，所以要先拿 right</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其实就是用栈保存每一个待排序子串的首尾元素下标，下一次 while 循环时取出这个范围，对这段子序列进行 partition 操作</span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty) &#123;</span><br><span class="line">        <span class="keyword">int</span> right = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">int</span> left = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = Partition(<span class="built_in">array</span>, left, right);</span><br><span class="line">        <span class="keyword">if</span> (index<span class="number">-1</span> &gt; left) &#123;</span><br><span class="line">            s.push(left);</span><br><span class="line">            s.push(index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index+<span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            s.push(index + <span class="number">1</span>);</span><br><span class="line">            s.push(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PartSort</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key = <span class="built_in">array</span>[right];</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">array</span>[left] &lt;= key) &#123;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[right] = <span class="built_in">array</span>[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; <span class="built_in">array</span>[right] &gt;= key) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[left] = <span class="built_in">array</span>[right];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[right] = key;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的反转</title>
      <link href="/2019/02/01/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/02/01/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表的反转"><a href="#单链表的反转" class="headerlink" title="单链表的反转"></a>单链表的反转</h2><hr><h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br></pre></td></tr></table></figure><h3 id="非递归写法"><a href="#非递归写法" class="headerlink" title="非递归写法"></a>非递归写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkNode *<span class="title">Reverse</span><span class="params">(LinkNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *pre = head;</span><br><span class="line">    LinkNode *cur = head-&gt;next;</span><br><span class="line">    LinkNode *temp = head-&gt;next-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkNode *<span class="title">Re_Reverse</span><span class="params">(LinkNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一直循环到链尾</span></span><br><span class="line">    LinkNode *newHead = Re_Reverse(head-&gt;next);</span><br><span class="line">    <span class="comment">// 翻转链表的指向</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    <span class="comment">// 记得赋值 NULL，防止链表错乱</span></span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 新链表头永远指向的是原链表的链尾</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树非递归遍历</title>
      <link href="/2019/02/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
      <url>/2019/02/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树非递归遍历"><a href="#二叉树非递归遍历" class="headerlink" title="二叉树非递归遍历"></a>二叉树非递归遍历</h2><hr><h3 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTNode *p;</span><br><span class="line">    p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || isEmpty(s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Pop(S, p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTNode *p;</span><br><span class="line">    p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || isEmpty(s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Pop(S, p);</span><br><span class="line">            visit(p);</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    InitStack(S);</span><br><span class="line">    BiTNode *p;</span><br><span class="line">    p = T;</span><br><span class="line">    r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (p || isEmpty(s)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            Push(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            GetTop(S, p);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild &amp;&amp; p-&gt;rchild != r) &#123;</span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">                Push(S, p);</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Pop(S, p);</span><br><span class="line">                visit(p);</span><br><span class="line">                r = p;</span><br><span class="line">                p = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DS&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DS&amp;A </tag>
            
            <tag> C++ </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中的 os.path.dirname(__file__) 的使用</title>
      <link href="/2017/07/02/Python%20%E4%B8%AD%E7%9A%84%20os.path.dirname(__file__)%20%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/07/02/Python%20%E4%B8%AD%E7%9A%84%20os.path.dirname(__file__)%20%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-中的-os-path-dirname-file-的使用"><a href="#Python-中的-os-path-dirname-file-的使用" class="headerlink" title="Python 中的 os.path.dirname(__file__) 的使用"></a>Python 中的 os.path.dirname(__file__) 的使用</h2><hr><h3 id="1-必须是实际存在的-py文件，如果在命令行执行，则会引发异常"><a href="#1-必须是实际存在的-py文件，如果在命令行执行，则会引发异常" class="headerlink" title="1. 必须是实际存在的.py文件，如果在命令行执行，则会引发异常"></a>1. 必须是实际存在的.py文件，如果在命令行执行，则会引发异常</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NameError: name &apos;__file__&apos; is not defined</span><br></pre></td></tr></table></figure><h3 id="2-返回的路径"><a href="#2-返回的路径" class="headerlink" title="2. 返回的路径"></a>2. 返回的路径</h3><p><strong>在运行的时候如果输入完整的执行的路径</strong></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yxd@yxd-virtual-machine:~/venv$ python /home/yxd/venv/test/test.py</span><br></pre></td></tr></table></figure><p><strong>则返回.py文件的全路路径</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/yxd/venv/test</span><br></pre></td></tr></table></figure><p><strong>如果是非完整路径且不在本目录下执行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yxd@yxd-virtual-machine:~/venv$ python test/test.py</span><br></pre></td></tr></table></figure><p><strong>则返回命令行输入的文件所在路径前面部分</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test</span><br></pre></td></tr></table></figure><p><strong>如果是在本目录下运行</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yxd@yxd-virtual-machine:~/venv/test$ python test.py</span><br></pre></td></tr></table></figure><p><strong>则返回空</strong></p><pre><code></code></pre><h3 id="3-结合os-path-abspath用，效果会更好"><a href="#3-结合os-path-abspath用，效果会更好" class="headerlink" title="3. 结合os.path.abspath用，效果会更好"></a>3. 结合os.path.abspath用，效果会更好</h3><p>Python项目的代码中，经常有这样的组合<br>os.path.dirname(os.path.abspath(__file__))或os.path.abspath(os.path.dirname(__file__))<br> <br><br>os.path.abspath(__file__)返回的是.py文件的绝对路径<br> </p><h3 id="4-os-path-dirname-file-的用法总结"><a href="#4-os-path-dirname-file-的用法总结" class="headerlink" title="4. os.path.dirname(__file__)的用法总结"></a>4. os.path.dirname(__file__)的用法总结</h3><ol><li>不要已命令行的形式使用os.path.dirname(__file__)</li><li>结合os.path.abspath()使用</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 日期格式，时间戳之间转换</title>
      <link href="/2017/07/01/Python%20%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%EF%BC%8C%E6%97%B6%E9%97%B4%E6%88%B3%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/"/>
      <url>/2017/07/01/Python%20%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%EF%BC%8C%E6%97%B6%E9%97%B4%E6%88%B3%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-日期格式，时间戳之间转换"><a href="#Python-日期格式，时间戳之间转换" class="headerlink" title="Python 日期格式，时间戳之间转换"></a>Python 日期格式，时间戳之间转换</h2><hr><h3 id="获取当前时间戳"><a href="#获取当前时间戳" class="headerlink" title="获取当前时间戳"></a>获取当前时间戳</h3><ul><li>方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = time.time()</span><br><span class="line">print(&apos;now:&apos;, now, &apos;\n&apos;, type(now))</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now: 1498926743.1411922 </span><br><span class="line"> &lt;class &apos;float&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="获取当前日期"><a href="#获取当前日期" class="headerlink" title="获取当前日期"></a>获取当前日期</h3><a id="more"></a><ul><li>方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">datenow = datetime.datetime.now()</span><br><span class="line">print(&apos;datenow:&apos;, datenow, &apos;\n&apos;, type(datenow))</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datenow: 2017-07-02 00:34:35.272749 </span><br><span class="line"> &lt;class &apos;datetime.datetime&apos;&gt;</span><br></pre></td></tr></table></figure><h3 id="字符串格式更改"><a href="#字符串格式更改" class="headerlink" title="字符串格式更改"></a>字符串格式更改</h3><p>如a = “2017-07-02 00:34:35”，想改为 a = “2017/07/02 00:34:35”</p><ul><li>方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = &quot;2013-10-10 23:40:00&quot;</span><br><span class="line">timeArray = time.strptime(a, &quot;%Y-%m-%d %H:%M:%S&quot;)                # 先转换为时间数组</span><br><span class="line">otherStyleTime = time.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;, timeArray)   # 转换为其他格式</span><br><span class="line">print(&apos;otherStyleTime:&apos;, otherStyleTime)</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherStyleTime: 2017/07/02 00:34:35</span><br></pre></td></tr></table></figure><h3 id="将字符串的时间转换为时间戳"><a href="#将字符串的时间转换为时间戳" class="headerlink" title="将字符串的时间转换为时间戳"></a>将字符串的时间转换为时间戳</h3><ul><li>方法：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = &quot;2017-07-02 00:34:35&quot; </span><br><span class="line">timeArray = time.strptime(a, &quot;%Y-%m-%d %H:%M:%S&quot;)            # 将其转换为时间数组</span><br><span class="line">timeStamp = int(time.mktime(timeArray))                      # 转换为时间戳</span><br><span class="line">print(&apos;timesStamp:&apos;, timeStamp)</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timesStamp: 1498926875</span><br></pre></td></tr></table></figure><h3 id="时间戳转换为指定格式日期"><a href="#时间戳转换为指定格式日期" class="headerlink" title="时间戳转换为指定格式日期"></a>时间戳转换为指定格式日期</h3><ul><li>方法一：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timeStamp = 1498927046</span><br><span class="line">timeArray = time.localtime(timeStamp)                              # 利用localtime()转换为时间数组</span><br><span class="line">otherStyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray)     # 格式化为需要的格式</span><br><span class="line">print(&apos;otherStyleTime:&apos;, otherStyleTime)</span><br></pre></td></tr></table></figure><ul><li>方法二：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timeStamp = 1498927046</span><br><span class="line">dateArray = datetime.datetime.fromtimestamp(timeStamp)</span><br><span class="line">otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">print(&apos;otherStyleTime:&apos;, otherStyleTime)</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherStyleTime: 2017-07-02 00:37:26</span><br></pre></td></tr></table></figure><h3 id="获取当前时间并转换为指定日期格式"><a href="#获取当前时间并转换为指定日期格式" class="headerlink" title="获取当前时间并转换为指定日期格式"></a>获取当前时间并转换为指定日期格式</h3><ul><li>方法一：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = int(time.time())                                             # 获得当前时间时间戳</span><br><span class="line">timeArray = time.localtime(now)</span><br><span class="line">StyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray)</span><br><span class="line">print(&apos;StyleTime:&apos;, StyleTime)</span><br></pre></td></tr></table></figure><ul><li>方法二：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">now = datetime.datetime.now()                                 # 获得当前时间，这是时间数组格式</span><br><span class="line">StyleTime = now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)                 # 转换为指定的格式</span><br><span class="line">print(&apos;StyleTime:&apos;, StyleTime)</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StyleTime: 2017-07-02 00:16:30</span><br></pre></td></tr></table></figure><h3 id="获得三天前的时间"><a href="#获得三天前的时间" class="headerlink" title="获得三天前的时间"></a>获得三天前的时间</h3><ul><li>方法:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threeDayAgo = (datetime.datetime.now() - datetime.timedelta(days = 3))   # 先获得时间数组格式的日期</span><br><span class="line">timeStamp = int(time.mktime(threeDayAgo.timetuple()))                    # 转换为时间戳</span><br><span class="line">threeDayAgo = threeDayAgo.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)                  # 转换为其他字符串格式</span><br><span class="line">print(&apos;threeDayAgo:&apos;, threeDayAgo)</span><br></pre></td></tr></table></figure><p>timedelta()的参数有:days, seconds, microseconds, milliseconds, minutes, hours, weeks</p><ul><li>输出结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threeDayAgo: 2017-06-29 00:21:04</span><br></pre></td></tr></table></figure><h3 id="给定时间戳-计算该时间的几天前时间"><a href="#给定时间戳-计算该时间的几天前时间" class="headerlink" title="给定时间戳,计算该时间的几天前时间:"></a>给定时间戳,计算该时间的几天前时间:</h3><ul><li>方法:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timeStamp = 1498926852</span><br><span class="line">dateArray = datetime.datetime.fromtimestamp(timeStamp)  # 先转换为datetime</span><br><span class="line">threeDayAgo = dateArray - datetime.timedelta(days=3)</span><br><span class="line">print(&apos;threeDayAgo:&apos;, threeDayAgo)</span><br></pre></td></tr></table></figure><ul><li>输出结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">threeDayAgo: 2017-06-28 16:34:12</span><br></pre></td></tr></table></figure><p>参考上面，可以转换为其他的任意格式</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
