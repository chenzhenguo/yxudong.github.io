<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 4]]></title>
    <url>%2F2020%2F09%2F29%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%204%2F</url>
    <content type="text"><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 4内存快照：宕机后，Redis如何实现快速恢复？ Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。 save：在主线程中执行，会导致阻塞； bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。 Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。 简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。 bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。 此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。 但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。 然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。 - 如果频繁地执行全量快照，也会带来两方面的开销。 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽， 前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。 另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。 虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程， 而且主线程的内存越大，阻塞时间越长。 如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。 Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。 简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。 这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。 而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了， 因此，就不会出现文件过大的情况了，也可以避免重写开销。 如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录， 等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。 - RDB 优势在于，可以快速恢复数据库，也就是只需要把 RDB 文件直接读入内存，避免了 AOF 需要顺序、逐一重新执行操作命令带来的低效性能问题。缺点是频繁快照很耗资源 - 三点建议 1. 数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择； 2. 如果允许分钟级别的数据丢失，可以只使用 RDB； 3. 如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 3]]></title>
    <url>%2F2020%2F09%2F29%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%203%2F</url>
    <content type="text"><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 3AOF日志：宕机了，Redis如何避免数据丢失？ Redis 的持久化主要有两大机制，即 AOF(Append Only File) 日志和 RDB(Redis DataBase) 快照。 AOF 日志是如何实现的？ AOF 日志写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。 - AOF 为什么要先执行命令再记日志呢？ 传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据， 而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。 以 Redis 收到 “set testkey testvalue” 命令后记录的日志为例，看看 AOF 日志的内容。 其中，“*3” 表示当前命令有三个部分，每部分都是由 “$+数字” 开头，后面紧跟着具体的命令、键或值。 这里，“数字” 表示这部分中的命令、键或值一共有多少字节。 例如，“$3 set” 表示这部分有 3 个字节，也就是 “set” 命令。 为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。 所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。 而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中， 否则，系统就会直接向客户端报错。 所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。 除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操作。 - AOF 两个潜在的风险 首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。 如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复， 但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。 其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。 这是因为，AOF 日志也是在主线程中执行的， 如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。 三种写回策略 对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选。 Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘； Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘； No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。 针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。 “同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能； “每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销， 虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。 所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。 虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令， 但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了； 三种策略的写回时机对比 想要获得高性能，就选择 No 策略； 如果想要得到高可靠性保证，就选择 Always 策略； 如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。 - AOF 文件过大带来的性能问题 这里的“性能问题”，主要在于以下三个方面： 一是，文件系统本身对文件大小有限制，无法保存过大的文件； 二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低； 三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复， 如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。 AOF 重写机制 AOF重写机制指的是，对过大的AOF文件进行重写，以此来压缩AOF文件的大小。 具体的实现是：检查当前键值数据库中的键值对，记录键值对的最终状态， 从而实现对某个键值对 重复操作后产生的多条操作记录压缩成一条的效果。进而实现压缩AOF文件的大小。 - AOF 重写会阻塞吗? 和 AOF 日志由主线程写回不同，重写过程是由后台线程 bgrewriteaof 来完成的， 这也是为了避免阻塞主线程，导致数据库性能下降。 AOF 重写过程 重写的过程总结为“一个拷贝，两处日志”。一个拷贝： 每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。 此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。 然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。两处日志： 因为主线程未阻塞，仍然可以处理新来的操作。 此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。 这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。 而第二处日志， 就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。 这样，重写日志也不会丢失最新的操作。 等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。 此时，我们就可以用新的 AOF 文件替代旧文件了。 总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。 对于开启 HugePages 的操作系统，父进程申请内存时阻塞的概率将会大大提高，Hugepages 在实际使用 Redis 并需要持久化时是建议关掉的。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 5]]></title>
    <url>%2F2020%2F09%2F29%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%205%20%23%23%23%23%2F</url>
    <content type="text"><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 5数据同步：主从库如何实现数据一致？ Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。 读操作：主库、从库都可以接收；写操作：首先到主库执行，然后，主库将写操作同步给从库。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 2]]></title>
    <url>%2F2020%2F09%2F28%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%202%2F</url>
    <content type="text"><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 2高性能IO模型：为什么单线程Redis能那么快？ Redis 单线程的理解 Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写（数据读写）是由一个线程来完成的， 这也是 Redis 对外提供键值存储服务的主要流程。 但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。 Redis 为什么用单线程？ 多线程编程模式面临共享资源的并发访问控制问题。 并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计， 比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果： 即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。 而且，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。 为了避免这些问题，Redis 直接采用了单线程模式。 单线程 Redis 为什么那么快？ 一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构， 例如哈希表和跳表，这是它实现高性能的一个重要原因。 另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。 基本 IO 模型与阻塞点 以 Get 请求为例，为了处理一个 Get 请求，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。下图显示了这一过程，其中，bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作。既然 Redis 是单线程，那么，最基本的一种实现是在一个线程中依次执行上面说的这些操作。 但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。 - 非阻塞模式在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。针对监听套接字，我们可以设置非阻塞模式： 当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。 但是，你要注意的是，调用 accept() 时，已经存在监听套接字了 - 基于多路复用的高性能 I/O 模型Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数。select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 1]]></title>
    <url>%2F2020%2F09%2F28%2F%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%20-%20%E3%80%8ARedis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98%E3%80%8B%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%201%2F</url>
    <content type="text"><![CDATA[极客时间 - 《Redis核心技术与实战》 学习笔记 1数据结构：快速的Redis有哪些慢操作？ Redis 表现突出的原因 一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。 另一方面，这要归功于它的数据结构。 这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作， 所以高效的数据结构是 Redis 快速处理数据的基础。 底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。 - 键和值用什么结构组织？为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。哈希桶中的 entry 元素中保存了 *key 和 *value 指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。 - 为什么哈希表操作变慢了？哈希表的冲突问题和 rehash 可能带来的操作阻塞。Redis 解决哈希冲突的方式，就是链式哈希。但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。所以，Redis 会对哈希表做 rehash 操作。 - 哈希表做 rehashrehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步： 1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍； 2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中； 3. 释放哈希表 1 的空间。到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。- 渐进式 rehash简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求。每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中。等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示： - 对于 String 类型来说，找到哈希桶就能直接增删改查了，所以，哈希表的 O(1) 操作复杂度也就是它的复杂度了。- 压缩列表压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。 - 跳表有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：当数据量很大时，跳表的查找复杂度就是 O(logN)。 - 数据结构的时间复杂度 四句口诀 单元素操作是基础； 范围操作非常耗时； 统计操作通常高效； 例外情况只有几个。 单元素操作 是指每一种集合类型对单个数据实现的增删改查操作。 例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。 这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)； Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。 这里，有个地方你需要注意一下，集合类型支持同时对多个元素进行增删改查， 例如 Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。 此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。 范围操作 是指集合类型中的遍历操作，可以返回集合中的所有数据。 比如 Hash 类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List 类型的 LRANGE 和 ZSet 类型的 ZRANGE。 这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。 Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。 这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。 统计操作 是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。 这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时， 这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。 例外情况 是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。 这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素， 这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。 复杂度较高的 List 类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。因此，因地制宜地使用 List 类型。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uWSGI、WSGI 和 uwsgi]]></title>
    <url>%2F2019%2F08%2F16%2FuWSGI%E3%80%81WSGI%20%E5%92%8C%20uwsgi%2F</url>
    <content type="text"><![CDATA[uWSGI、WSGI 和 uwsgi 图解 WSGIwsgi server（比如 uWSGI）要和 wsgi application（比如 django ）交互，uWSGI 需要将过来的请求转给 django 处理，那么 uWSGI 和 django 的交互和调用就需要一个统一的规范，这个规范就是 WSGI。 WSGI，全称 Web Server Gateway Interface，或者 Python Web Server Gateway Interface，是为 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。自从 WSGI 被开发出来以后，许多其它语言中也出现了类似接口。 WSGI 的官方定义是，the Python Web Server Gateway Interface。从名字就可以看出来，这东西是一个 Gateway，也就是网关。网关的作用就是在协议之间进行转换。 WSGI 是作为 Web 服务器与 Web 应用程序或应用框架之间的一种低级别的接口，以提升可移植 Web 应用开发的共同点。WSGI 是基于现存的 CGI 标准而设计的。 uWSGIuWSGI 是一个 Web 服务器，它实现了 WSGI 协议、uwsgi、http 等协议。Nginx 中 HttpUwsgiModule 的作用是与 uWSGI 服务器进行交换。 uwsgi与 WSGI 一样是一种通信协议，是 uWSGI 服务器的独占协议，用于定义传输信息的类型（type of information），每一个 uwsgi packet 前 4byte 为传输信息类型的描述，与 WSGI 协议是两种东西，据说该协议是 fcgi 协议的 10 倍快。 FastCgi 协议， uwsgi 协议与 http 协议有什么用？nginx 和下游服务器交互就必须使用同一个协议，只要大家沟通好使用哪个协议，就可以正常运行了。 这三种协议就是 nginx 为了与下游服务器交互事先约定好的协议。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra 最短路径算法 Python 实现]]></title>
    <url>%2F2019%2F06%2F27%2FDijkstra%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%20Python%20%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Dijkstra 最短路径算法 Python 实现 问题描述使用 Dijkstra 算法求图中的任意顶点到其它顶点的最短路径（求出需要经过那些点以及最短距离）。 以下图为例： 算法思想可以使用二维数组来存储顶点之间边的关系 首先需要用一个一维数组 dis 来存储 初始顶点到其余各个顶点的初始路程，以求 1 顶点到其它各个顶点为例： 将此时 dis 数组中的值称为最短路的“估计值”。 既然是求 1 号顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离 1 号顶点最近是 2 号顶点。当选择了 2 号顶点后，dis[2] 的值就已经从“估计值”变为了“确定值”，即 1 号顶点到 2 号顶点的最短路程就是当前 dis[2]值。为什么呢？因为目前离 1 号顶点最近的是 2 号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 1 号顶点到 2 号顶点的路程进一步缩短了。 既然选了 2 号顶点，接下来再来看 2 号顶点有哪些出边。有 2-&gt;3 和 2-&gt;4 这两条边。先讨论通过 2-&gt;3 这条边能否让 1 号顶点到 3 号顶点的路程变短。也就是说现在比较 dis[3] 和 dis[2] + G[2][3]的大小。其中 dis[3] 表示 1 号顶点到 3 号顶点的路程。dis[2] + G[2][3] 中 dis[2] 表示 1 号顶点到 2 号顶点的路程，G[2][3] 表示 2-&gt;3 这条边。所以 dis[2] + G[2][3] 就表示从 1 号顶点先到 2 号顶点，再通过 2-&gt;3 这条边，到达 3 号顶点的路程。 在本例中 dis[3] = 12，dis[2] + G[2][3] = 1 + 9 = 10，dis[3] &gt; dis[2] + G[2][3]，所以 dis[3] 要更新为 10。这个过程有个专业术语叫做“松弛”。即 1 号顶点到 3 号顶点的路程即 dis[3]，通过 2-&gt;3 这条边松弛成功。这是 Dijkstra 算法的主要思想：通过“边”来松弛初始顶点到其余各个顶点的路程。 同理通过 2-&gt;4（G[2][4]），可以将 dis[4]的值从 ∞ 松弛为 4（dis[4] 初始为 ∞，dis[2] + G[2][4] = 1 + 3 = 4，dis[4] &gt; dis[2] + G[2][4]，所以 dis[4] 要更新为 4）。 刚才对 2 号顶点所有的出边进行了松弛。松弛完毕之后 dis 数组为： 接下来，继续在剩下的 3、4、5 和 6 号顶点中，选出离 1 号顶点最近的顶点。通过上面更新过 dis 数组，当前离 1 号顶点最近是 4 号顶点。此时，dis[4] 的值已经从“估计值”变为了“确定值”。下面继续对 4 号顶点的所有出边（4-&gt;3，4-&gt;5 和 4-&gt;6）用刚才的方法进行松弛。松弛完毕之后 dis 数组为： 继续在剩下的 3、5 和 6 号顶点中，选出离 1 号顶点最近的顶点，这次选择 3 号顶点。此时，dis[3] 的值已经从“估计值”变为了“确定值”。对 3 号顶点的所有出边（3-&gt;5）进行松弛。松弛完毕之后 dis 数组为： 继续在剩下的 5 和 6 号顶点中，选出离 1 号顶点最近的顶点，这次选择 5 号顶点。此时，dis[5] 的值已经从“估计值”变为了“确定值”。对5号顶点的所有出边（5-&gt;4）进行松弛。松弛完毕之后 dis 数组为： 最后对 6 号顶点所有点出边进行松弛。因为这个例子中 6 号顶点没有出边，因此不用处理。到此，dis 数组中所有的值都已经从“估计值”变为了“确定值”。 最终 dis 数组如下，这便是 1 号顶点到其余各个顶点的最短路径。 总结一下刚才的算法。算法的基本思想是：每次找到离源点（上面例子的源点就是 1 号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下： 将所有的顶点分为两部分：已知最短路程的顶点集合 P 和未知最短路径的顶点集合 Q。最开始，已知最短路径的顶点集合 P 中只有源点一个顶点。这里用一个 visited[ i ]数组来记录哪些点在集合 P 中。例如对于某个顶点 i，如果 visited[ i ]为 1 则表示这个顶点在集合 P 中，如果 visited[ i ]为 0 则表示这个顶点在集合 Q 中； 设置源点 s 到自己的最短路径为 0 即 dis = 0。若存在源点有能直接到达的顶点 i，则把 dis[ i ]设为 G[s][ i ]。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为 ∞； 在集合 Q 的所有顶点中选择一个离源点 s 最近的顶点 u（即 dis[u] 最小）加入到集合 P。并考察所有以点 u 为起点的边，对每一条边进行松弛操作。例如存在一条从 u 到 v 的边，那么可以通过将边 u-&gt;v 添加到尾部来拓展一条从 s 到 v 的路径，这条路径的长度是 dis[u] + G[u][v]。如果这个值比目前已知的 dis[v] 的值要小，我们可以用新值来替代当前 dis[v] 中的值； 重复第 3 步，如果集合 Q 为空，算法结束。最终 dis 数组中的值就是源点到所有顶点的最短路径 Dijkstra 算法不能应用于有负权重的图 Dijkstra 时间复杂度为 O(N2) Python 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950def Dijkstra(G, start): # 输入是从 0 开始，所以起始点减 1 start = start - 1 inf = float('inf') node_num = len(G) # visited 代表哪些顶点加入过 visited = [0] * node_num # 初始顶点到其余顶点的距离 dis = &#123;node: G[start][node] for node in range(node_num)&#125; # parents 代表最终求出最短路径后，每个顶点的上一个顶点是谁，初始化为 -1，代表无上一个顶点 parents = &#123;node: -1 for node in range(node_num)&#125; # 起始点加入进 visited 数组 visited[start] = 1 # 最开始的上一个顶点为初始顶点 last_point = start for i in range(node_num - 1): # 求出 dis 中未加入 visited 数组的最短距离和顶点 min_dis = inf for j in range(node_num): if visited[j] == 0 and dis[j] &lt; min_dis: min_dis = dis[j] # 把该顶点做为下次遍历的上一个顶点 last_point = j # 最短顶点假加入 visited 数组 visited[last_point] = 1 # 对首次循环做特殊处理，不然在首次循环时会没法求出该点的上一个顶点 if i == 0: parents[last_point] = start + 1 for k in range(node_num): if G[last_point][k] &lt; inf and dis[k] &gt; dis[last_point] + G[last_point][k]: # 如果有更短的路径，更新 dis 和 记录 parents dis[k] = dis[last_point] + G[last_point][k] parents[k] = last_point + 1 # 因为从 0 开始，最后把顶点都加 1 return &#123;key + 1: values for key, values in dis.items()&#125;, &#123;key + 1: values for key, values in parents.items()&#125;if __name__ == '__main__': inf = float('inf') G = [[0, 1, 12, inf, inf, inf], [inf, 0, 9, 3, inf, inf], [inf, inf, 0, inf, 5, inf], [inf, inf, 4, 0, 13, 15], [inf, inf, inf, inf, 0, 4], [inf, inf, inf, inf, inf, 0]] dis, parents = Dijkstra(G, 1) print("dis: ", dis) print("parents: ", parents) 输出为 12dis: &#123;1: 0, 2: 1, 3: 8, 4: 4, 5: 13, 6: 17&#125;parents: &#123;1: -1, 2: 1, 3: 4, 4: 2, 5: 3, 6: 5&#125; 如果求 1 号顶点到 6 号顶点的最短距离，dis[6] = 17，所以最短距离为 17。 再看 parents[6] = 5，说明 6 号顶点的上一个顶点为 5，parents[5] = 3，说明 5 号顶点的上一个顶点为 3，以此类推，最终 1 号顶点到 6 号顶点的路径为 1-&gt;2-&gt;4-&gt;3-&gt;5-&gt;6。 优化思路 其中每次找到离 1 号顶点最近的顶点的时间复杂度是 O(N)，可以用“堆”来优化，使得这一部分的时间复杂度降低到 O(logN)； 另外对于边数 M 少于 N2 的稀疏图来说（把 M 远小于 N2 的图称为稀疏图，而 M 相对较大的图称为稠密图），可以用邻接表来代替邻接矩阵，使得整个时间复杂度优化到 O((M+N)logN)。注意，在最坏的情况下 M 就是 N2，这样的话 MlogN 要比 N2 还要大。但是大多数情况下并不会有那么多边，所以 (M+N)logN 要比 N2 小很多]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>DS&amp;A</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 14. Longest Common Prefix]]></title>
    <url>%2F2019%2F03%2F10%2FLeetCode%2014.%20Longest%20Common%20Prefix%2F</url>
    <content type="text"><![CDATA[LeetCode 14. Longest Common Prefix 题目描述Write a function to find the longest common prefix string amongst an array of strings.If there is no common prefix, return an empty string “”. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 12Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot; Explanation: There is no common prefix among the input strings. Note:All given inputs are in lowercase letters a-z. 解题代码一1234567891011121314151617class Solution: def longestCommonPrefix(self, strs): if not strs: return "" minl = len(min(strs, key=len)) s = "" for i in range(minl): c = strs[0][i] flag = 1 for j in range(1, len(strs)): if strs[j][i] != c: flag = 0 break if not flag: break s += c return s 解题代码二123456789101112class Solution: def longestCommonPrefix(self, strs): if not strs: return "" for i, letter_group in enumerate(zip(*strs)): # strs = ["flower","flow","flight"] 时 # list(zip(*strs)) 为 [('f', 'f', 'f'), ('l', 'l', 'l'), ('o', 'o', 'i'), ('w', 'w', 'g')] if len(set(letter_group)) &gt; 1: return strs[0][:i] return min(strs)]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>DS&amp;A</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个链表的第一个公共结点]]></title>
    <url>%2F2019%2F03%2F03%2F%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[两个链表的第一个公共结点 题目描述输入两个链表，找出它们的第一个公共结点。 思路一 首先，如果两个链表有公共结点，那么这个结点以及之后的结点必然是一样的，因为公共结点里的 next 值是相同的； 计算出两个链表的长度差； 让长的链表先走长度差的距离，然后两链表同时向后走，直到两结点相等，就可以求出第一个公共结点 解题代码一123456789101112131415161718192021222324252627282930313233343536/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123; public: ListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2) &#123; int len1 = 0, len2 = 0; ListNode *p1 = pHead1, *p2 = pHead2; while (p1) &#123; p1 = p1-&gt;next; ++len1; &#125; while (p2) &#123; p2 = p2-&gt;next; ++len2; &#125; // 求出两个链表长度 int dlen = len1 &gt; len2 ? len1 - len2 : len2 - len1; p1 = len1 &gt; len2 ? pHead1 : pHead2; p2 = len1 &gt; len2 ? pHead2 : pHead1; while (dlen) &#123; p1 = p1-&gt;next; --dlen; &#125; // 长的链表先向后走长度差的距离 while (p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; // 同时向后走直到相遇 return p1; &#125;&#125;; 思路二 假定 List1 长度：a+n，List2 长度：b+n, 且 a&lt;b，那么 p1 会先到链表尾部, 这时 p2 走到 a+n 位置，将 p1 换成 List2 头部； 接着 p2 再走 b+n-(a+n)=b-a 步到链表尾部，这时 p1 也走到 List2 的 b-a 位置，还差 a 步就到可能的第一个公共结点； 将 p2 换成 List1 头部，p2 走 a 步也到可能的第一个公共节点。如果恰好 p1==p2，那么 p1 就是第一个公共结点。或者 p1 和 p2 一起走 n 步到达链表尾部，两链表没有公共结点，退出循环； a&gt;=b 同理 解题代码二1234567891011121314151617181920212223242526272829303132/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123; public: ListNode *FindFirstCommonNode(ListNode *pHead1, ListNode *pHead2) &#123; ListNode *p1 = pHead1; ListNode *p2 = pHead2; while (p1 != p2) &#123; if (p1 != NULL) &#123; p1 = p1-&gt;next; &#125; else &#123; p1 = pHead2; &#125; if (p2 != NULL) &#123; p2 = p2-&gt;next; &#125; else &#123; p2 = pHead1; &#125; &#125; return p1; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和为 S 的两个数字]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%92%8C%E4%B8%BA%20S%20%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[和为 S 的两个数字 题目描述输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S，如果有多对数字的和等于 S，输出两个数的乘积最小的。 输出描述:对应每个测试案例，输出两个数，小的先输出。 解题思路 数列满足递增，设两个头尾两个指针 i 和 j； 若 array[i] + array[j] = sum，就是答案； 若 array[i] + array[j] &gt; sum，大的数向左移，j -= 1； 若 array[i] + array[j] &lt; sum，小的数向右移，i += 1； 本题最开始解法为利用数组存下所有结果，然后再比较两个数的乘积最小作为结果，但可以证明，两数距离最远的结果（找到的第一组）就是乘积最小的结果： 12345假设 x+y=C（C 是常数），求 x*y 的最小值不妨设 y&gt;=x，y-x=d&gt;=0，即 y=x+d，2x+d=C，x=(C-d)/2所以 x*y=x(x+d)=(C-d)(C+d)/4=(C^2-d^2)/4也就是 x*y 是一个关于变量 d 的二次函数，对称轴是 y 轴，开口向下d 是 &gt;=0 的，d 越大，x*y 也就越小 解题代码最初版本： 1234567891011121314151617181920212223242526272829303132class Solution &#123; public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; result; int i = 0, j = array.size() - 1; while (i &lt; j) &#123; if ((array[i] + array[j]) &gt; sum) &#123; --j; &#125; else if ((array[i] + array[j]) &lt; sum) &#123; ++i; &#125; else &#123; vector&lt;int&gt; v = &#123;array[i], array[j]&#125;; result.push_back(v); ++i; &#125; &#125; vector&lt;int&gt; r; if (result.size() == 0) &#123; return r; &#125; r = result[0]; for (int i = 0; i &lt; result.size(); ++i) &#123; if (result[i][0] * result[i][1] &lt; r[0] * r[1]) &#123; r[0] = result[i][0]; r[1] = result[i][1]; &#125; &#125; return r; &#125;&#125;; 改进代码： 123456789101112131415161718192021class Solution &#123; public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array, int sum) &#123; vector&lt;int&gt; result; int i = 0, j = array.size() - 1; while (i &lt; j) &#123; if ((array[i] + array[j]) &gt; sum) &#123; --j; &#125; else if ((array[i] + array[j]) &lt; sum) &#123; ++i; &#125; else &#123; result.push_back(array[i]); result.push_back(array[j]); break; &#125; &#125; return result; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连续子数组的最大和]]></title>
    <url>%2F2019%2F03%2F02%2F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[连续子数组的最大和 题目描述HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了：在古老的一维模式识别中，常常需要计算连续子向量的最大和,当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？例如：{6, -3, -2, 7, -15, 1, 2, 2}，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止）。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？（子向量的长度至少是 1）。 解题思路 用 total 记录累计值，maxSum 记录最大和； 对于一个数 A，若是 A 的左边累计数非负，那么加上 A 能使得值不小于 A，则认为累计值对整体和是有贡献的； 如果前几项累计值负数，则认为有害于总和，total 变为当前值。每次改变 total 后，若大于 maxSum，则 maxSum等于 total 解题代码12345678910111213141516171819class Solution &#123; public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; // 用 total 记录累计值，maxSum 记录最大和，初始值为第一个元素 int total = array[0], maxSum = array[0]; for (int i = 1; i &lt; array.size(); ++i) &#123; if (total &gt;= 0) &#123; total += array[i]; &#125; else &#123; total = array[i]; &#125; if (total &gt; maxSum) &#123; maxSum = total; &#125; &#125; return maxSum; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中只出现一次的数字]]></title>
    <url>%2F2019%2F03%2F02%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中只出现一次的数字 题目描述一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 解题思路 首先，位运算中异或的性质：两个相同数字异或为 0，一个数和 0 异或还是它本身； 当只有一个数出现一次时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了； 依照这个思路，我们来看两个数（我们假设是 AB）出现一次的数组。首先还是先异或，剩下的数字肯定是 A、B 异或的结果，这个结果的二进制中的 1，表现的是 A 和 B 的不同的位。我们就取最低位的 1 所在的位数，假设是第 3 位。接着把原数组分成两组，分组标准是第 3 位是否为 1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字 解题代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public: void FindNumsAppearOnce(vector&lt;int&gt; data, int* num1, int *num2) &#123; // 首先对所有数依次异或 int bitResult = 0; for (int i = 0; i &lt; data.size(); ++i) &#123; bitResult ^= data[i]; ) // 找到最低位为 1 的是第几位 int index = 0; while ((bitResult &amp; 1) == 0) &#123; bitResult &gt;&gt;= 1; // 找不到的话右移一位 ++index; &#125; *num1 = 0; *num2 = 0; for (int i = 0; i &lt; data.size(); ++i) &#123; // 分组 if (isBit1(data[i], index)) &#123; *num1 ^= data[i]; &#125; else &#123; *num2 ^= data[i]; &#125; &#125; &#125; // 判断第 index 位是否为 1 bool isBit1(int num, int index) &#123; return ((num &gt;&gt; index) &amp; 1) == 1; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉搜索树的后序遍历序列]]></title>
    <url>%2F2019%2F03%2F02%2F%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[二叉搜索树的后序遍历序列 题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes,否则输出 No。假设输入的数组的任意两个数字都互不相同。 解题思路 后序遍历的序列中，最后一个数字是树的根节点； 数组中前面的数字可以分为两部分：第一部分是左子树节点的值，都比根节点的值小；第二部分是右子树节点的值，都比根节点的值大； 后面用递归分别判断左右两部分是否符合以上原则 解题代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public: bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if (sequence.size() == 0) &#123; return false; &#125; // 初始边界值为数组最初左右边界 int left = 0, right = sequence.size() - 1; return judge(sequence, left, right); &#125; bool judge(vector&lt;int&gt; sequence, int left, int right) &#123; if (left &gt;= right) &#123; return true; &#125; // 左边界大于等于右边界返回 true int root = sequence[right]; // 根节点 int i, j; for (i = left; i &lt; right; ++i) &#123; if (sequence[i] &gt; root) &#123; break; &#125; &#125; // 左半子树都小于根节点，寻找到右半子树起始位置 for (j = i; j &lt; right; ++j) &#123; if (sequence[j] &lt; root) &#123; return false; &#125; &#125; // 右半子树都大于根节点，否则 false // 递归处理左右子树 return judge(sequence, left, i - 1) &amp;&amp; judge(sequence, i, right - 1); &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈的压入、弹出序列]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[栈的压入、弹出序列 题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列 1, 2, 3, 4, 5 是某栈的压入顺序，序列 4, 5, 3, 2, 1 是该压栈序列对应的一个弹出序列，但 4, 3, 5, 1, 2 就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。 解题思路 模拟栈操作，将压栈序列依次压入辅助栈，每次压入栈的元素与所给弹出序列相比，如果相同则出栈，如果不同则继续压栈，直到原压栈序列中所有数字压栈完毕； 检测辅助栈中是否为空，若空，说明弹出序列可由原压栈序列进行栈操作得到。否则，说明弹出队列不能由原压栈序列进行栈操作得到 解题代码123456789101112131415class Solution &#123; public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; stack&lt;int&gt; s; int j = 0; // 设置出栈队列的起始下标 for (int i = 0; i &lt; pushV.size(); ++i) &#123; s.push(pushV[i]); while (!s.empty() &amp;&amp; s.top() == popV[j]) &#123; s.pop(); ++j; &#125; &#125; return s.empty(); &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用两个栈实现队列]]></title>
    <url>%2F2019%2F02%2F28%2F%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[用两个栈实现队列 题目描述用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。 解题思路 入队：直接 push 进 stack1； 出队：判断 stack2 是否为空，如果为空，则将 stack1 中所有元素 pop，并 push 进 stack2，stack2 出栈；如果不为空，stack2 直接出栈 解题代码1234567891011121314151617181920212223242526class Solution&#123; public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; if (stack2.empty()) &#123; int temp; while (!stack1.empty()) &#123; temp = stack1.top(); stack1.pop(); stack2.push(temp); &#125; &#125; int node; node = stack2.top(); stack2.pop(); return node; &#125; private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2; &#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺时针打印矩阵]]></title>
    <url>%2F2019%2F02%2F27%2F%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[顺时针打印矩阵 题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下 4X4 矩阵：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10。 解题思路 每次都是一个圈，所以定义四个变量限定每次循环的界限：startRow, endRow, startCol, endCol； 分别把首行，末列，末行，首列的数据依次加入 vector； 为了不重复加入元素，每次走完一圈后重新限定界限 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; public: vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt;&gt; matrix) &#123; vector&lt;int&gt; v; if (matrix.size() == 0) &#123; return v; &#125; if (matrix[0].size() == 0) &#123; return v; &#125; // 起始的四个界限 int startRow = 0; int endRow = matrix.size() - 1; int startCol = 0; int endCol = matrix[0].size() - 1; while (startRow &lt;= endRow &amp;&amp; startCol &lt;= endCol) &#123; // 矩阵最终可能会剩下一行或一列，如果不这么处理，会重复加入元素 // 如果就剩下一行 if (startRow == endRow) &#123; for (int i = startCol;i &lt;= endCol; ++i) &#123; v.push_back(matrix[startRow][i]); &#125; return v; &#125; // 如果就剩下一列 if (startCol == endCol) &#123; for (int i = startRow; i &lt;= endRow; ++i) &#123; v.push_back(matrix[i][startCol]); &#125; return v; &#125; // 首行 for (int i = startCol; i &lt;= endCol; ++i) &#123; v.push_back(matrix[startRow][i]); &#125; // 末列 for (int i = startRow + 1; i &lt;= endRow; ++i) &#123; v.push_back(matrix[i][endCol]); &#125; // 末行 for (int i = endCol - 1; i &gt;= startCol; --i) &#123; v.push_back(matrix[endRow][i]); &#125; // 首列 for (int i = endRow-1; i &gt;= startRow + 1; --i) &#123; v.push_back(matrix[i][startCol]); &#125; startRow = startRow + 1; endRow = endRow - 1; startCol = startCol + 1; endCol = endCol - 1; &#125; return v; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求 1 + 2 + 3 + ... + n]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%B1%82%201%20%2B%202%20%2B%203%20%2B%20...%20%2B%20n%2F</url>
    <content type="text"><![CDATA[求 1 + 2 + 3 + … + n 题目描述求 1 + 2 + 3 + … + n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（ A ? B : C）。 解题思路 利用逻辑与的短路特性实现递归终止； 当 n == 0 时，(n &gt; 0) &amp;&amp; ((sum += Sum_Solution(n - 1)) &gt; 0) 只执行前面的判断，为 false，然后直接返回 0； 当 n &gt; 0 时，执行 sum += Sum_Solution(n - 1)，实现递归计算 Sum_Solution(n) 解题代码12345678class Solution &#123; public: int Sum_Solution(int n) &#123; int sum = n; (n &gt; 0) &amp;&amp; (sum += Sum_Solution(n - 1)); return sum; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组中出现次数超过一半的数字]]></title>
    <url>%2F2019%2F02%2F24%2F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[数组中出现次数超过一半的数字 题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组 {1, 2, 3, 2, 2, 2, 5, 4, 2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。 思路一 题目中要找的数字出现的次数超过数组长度的一半，也就是说它出现的次数比其他所有数字出现的次数的和还要多； 我们可以考虑在遍历数组的时候保存两个值：一个是数组中的一个数字，一个是次数； 当我们遍历到下一个数字的时，如果下一个数字和当前我们保存的数字相同，则次数加 1；如果和当前我们保存的数字不同，则次数减 1；当次数减到 0 的时候，我们将保存的数字改为当前遍历所处的位置，并将次数更改为 1 解题代码一123456789101112131415161718192021222324252627class Solution &#123; public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; int r = numbers[0]; int count = 1; for (int i = 1; i &lt; numbers.size(); ++i) &#123; if (count == 0) &#123; r = numbers[i]; count = 1; &#125; else if (numbers[i] == r) &#123; ++count; &#125; else &#123; --count; &#125; &#125; // 看最后一个元素个数是否超过长度一半 count = 0; for (int i = 0; i &lt; numbers.size(); ++i) &#123; if (numbers[i] == r) &#123; ++count; &#125; &#125; return count &gt; numbers.size() / 2 ? r : 0; &#125;&#125;; 思路二首先将容器中的数字排序，排序结束后，如果存在次数大于数组大小一半的数，必定在数组中间位置 解题代码二123456789101112131415class Solution &#123; public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; sort(numbers.begin(),numbers.end()); int half = numbers.size() / 2; int count = 0; for (int i = 0; i &lt; numbers.size(); ++i) &#123; if (numbers[i]==numbers[half]) &#123; ++count; &#125; &#125; return count &gt; half ? numbers[half] : 0; &#125;&#125;; 思路三利用 map 把每个数字出现的次数储存起来 解题代码三12345678910111213141516171819class Solution &#123; public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; map&lt;int, int&gt; numbersMap; for (int i = 0; i &lt; numbers.size(); ++i) &#123; numbersMap[numbers[i]] += 1; &#125; int half = numbers.size() / 2; int number = 0; for (map&lt;int, int&gt;::iterator it = numbersMap.begin(); it != numbersMap.end(); ++it) &#123; if (it-&gt;second &gt; half) &#123; number = it-&gt;first; break; &#125; &#125; return number; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包含 min 函数的栈]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%8C%85%E5%90%AB%20min%20%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88%2F</url>
    <content type="text"><![CDATA[包含 min 函数的栈 题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为 O（1））。 解题代码12345678910111213141516171819202122232425262728293031323334class Solution &#123; public: // s 为常规的栈 // smin 为保存最小值的栈，其中顶部永远为最小值 stack&lt;int&gt; s, smin; void push(int value) &#123; s.push(value); // s 正常压栈 if (smin.empty()) &#123; smin.push(value); // smin 为空，直接进栈 &#125; else if (value &lt;= smin.top()) &#123; smin.push(value); // 待进栈元素小于最小值时，才会进入 smin 栈 &#125; &#125; void pop() &#123; int n = s.top(); s.pop(); // s 正常弹出 if (n == smin.top()) &#123; smin.pop(); // 如果弹出元素为最小值，smin 顶部也弹出 &#125; &#125; int top() &#123; // 直接返回顶部即可 return s.top(); &#125; int min() &#123; // 返回 smin 顶部 return smin.top(); &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的深度]]></title>
    <url>%2F2019%2F02%2F23%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树的深度 题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 递归解法1234567891011121314151617181920212223/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123; public: int TreeDepth(TreeNode *pRoot) &#123; if (!pRoot) &#123; return 0; // 若为空树，深度为 0 &#125; else &#123; // 采用后序遍历 int dl = TreeDepth(pRoot-&gt;left); int dr = TreeDepth(pRoot-&gt;right); return (dl &gt; dr? dl : dr) + 1; &#125; &#125;&#125;; 非递归解法1234567891011121314151617181920212223242526272829303132333435363738/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123; public: int TreeDepth(TreeNode *pRoot) &#123; if (!pRoot) &#123; return 0; &#125; queue&lt;TreeNode *&gt; q; q.push(pRoot); int level = 0; while (!q.empty()) &#123; ++level; int len = q.size(); while (len &gt; 0) &#123; TreeNode *p = q.front(); q.pop(); if (p-&gt;left) &#123; q.push(p-&gt;left); &#125; if (p-&gt;right) &#123; q.push(p-&gt;right); &#125; --len; &#125; &#125; return level; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算日期差]]></title>
    <url>%2F2019%2F02%2F23%2F%E8%AE%A1%E7%AE%97%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E6%97%A5%E6%9C%9F%E5%B7%AE%2F</url>
    <content type="text"><![CDATA[计算任意两个日期差 题目描述有两个日期，求两个日期之间的天数，如果两个日期是连续的我们规定他们之间的天数为两天 输入： 有多组数据，每组数据有两行，分别表示两个日期，形式为 YYYYMMDD 输出： 每组数据输出一行，即日期差值 样例输入： 2011041220110422 样例输出： 11 解题方法该题目是求两个日期间的天数差，即求分别以两个特定日期为界的日期区间的长度。解决这类区间问题有一个统一的思想——把原区间问题统一到起点确定的区间问题上去。采用预处理手段，即在程序真正开始处理输入数据之前，预处理出所有日期与原点日期之间的天数差并保存起来。再者，预处理也是空间换时间的重要手段（保存预处理所得数据所需的内存来换取实时处理所需要的时间消耗）日期类问题有个需要注意的要点——闰年，闰年并不严格按照四年一次的规律出现，在某种情况下也可能出现两个相邻闰年相隔8年的情况（如1896年与1904年）。即应采用该如下代码表示： 1#define ISYEAP(X) X%100 != 0 &amp;&amp; X%4 == 0 || X%400 == 0 ? 1:0 当需要开辟大量内存空间的情况，必须在函数体外定义，即定义全局变量，或者在函数中使用malloc等函数动态申请变量空间。即下面的代码中的buf[5001][13][32]在保存某个特定日期与原点日期的天数差时，使用了三维数组，用年、月、日分别表示该数组下标，便将日期本身与其存储地址联系起来，通过利用它的年月日数字即可找到我们保存的值，即Hash的基本思想。 解题代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;cmath&gt;// 定义宏判断是否是闰年#define ISYEAP(x) x % 100 != 0 &amp;&amp; x % 4 == 0 || x % 400 == 0 ? 1 : 0int dayOfMonth[13][2] = &#123; 0, 0, 31, 31, 28, 29, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31, 31, 31, 30, 30, 31, 31, 30, 30, 31, 31&#125;; // 预存每月的天数，二月配合宏定义做特殊处理struct Date &#123; int Day; int Month; int Year; void nextDay() &#123; // 计算下一天的日期 ++Day; if (Day &gt; dayOfMonth[Month][ISYEAP(Year)]) &#123; // 若日数超过了当月最大日数 Day = 1; ++Month; if (Month &gt; 12) &#123; // 若月份超过 12 Month = 1; ++Year; &#125; &#125; &#125;&#125;;int buf[5001][13][32]; // 保存预处理的天数int main() &#123; Date tmp; int cnt = 0; tmp.Day = 0; tmp.Month = 0; tmp.Year = 0; while (tmp.Year != 5001) &#123; buf[tmp.Year][tmp.Month][tmp.Day] = cnt; tmp.nextDay(); ++cnt; &#125; int d1, m1, y1; int d2, m2, y2; while (scanf("%4d%2d%2d", &amp;y1, &amp;m1, &amp;d1) != EOF) &#123; scanf("%4d%2d%2d", &amp;y2, &amp;m2, &amp;d2); printf("%d\n", abs(buf[y1][m1][d1] - buf[y2][m2][d2]) + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LintCode 20. 骰子求和]]></title>
    <url>%2F2019%2F02%2F23%2FLintCode%2020.%20%E9%AA%B0%E5%AD%90%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[LintCode 20. 骰子求和 题目描述扔 n 个骰子，向上面的数字之和为 S。给定 Given n，请列出所有可能的 S 值及其相应的概率。 样例给定 n = 1，返回 [[1, 0.17], [2, 0.17], [3, 0.17], [4, 0.17], [5, 0.17], [6, 0.17]]。 注意事项你不需要关心结果的准确性，我们会帮你输出结果。 思路递归求解，dicesSum(n) 可以用 dicesSum(n-1) 和 dicesSum(1) 来求解。利用 map 存放向上的数字之和与概率。 解题代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public: /** * @param n an integer * @return a list of pair&lt;sum, probability&gt; */ // 递归求骰子的概率 map&lt;int, double&gt; get_next(int n) &#123; map&lt;int, double&gt; m; for (int i = 1; i &lt;= 6; ++i) &#123; m[i] = (double)1 / 6; &#125; // m 为一次的概率 if (n == 1) &#123; return m; &#125; map&lt;int, double&gt; chance = get_next(n - 1); // 递归获取 n-1 的概率 map&lt;int, double&gt; r; for (auto i : m) &#123; for (auto c : chance) &#123; r[i.first + c.first] += i.second*c.second; // 循环遍历，相加和共 6 种情况，存在对应的 key 中 &#125; &#125; return r; &#125; vector&lt;pair&lt;int, double&gt;&gt; dicesSum(int n) &#123; vector&lt;pair&lt;int, double&gt;&gt; vec; map&lt;int, double&gt; m = get_next(n); for (auto i : m) &#123; vec.push_back(make_pair(i.first, i.second)); &#125; return vec; &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先序和中序确定二叉树]]></title>
    <url>%2F2019%2F02%2F23%2F%E5%85%88%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[先序和中序确定二叉树 题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列 {1, 2, 4, 7, 3, 5, 6, 8} 和中序遍历序列 {4, 7, 2, 1, 5, 3, 8, 6}，则重建二叉树并返回。 解题代码12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: TreeNode *reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; vin) &#123; // l1, h1 为先序序列的第一个和最后一个结点下标，l2, h2 为中序序列的第一个和最后一个结点下标 // 初始调用时，l1 = l2 = 0，h1 = h2 = size() - 1 int l1 = 0, h1 = pre.size() - 1, l2 = 0, h2 = vin.size() - 1; TreeNode *root = reConstructBinaryTree_recursion(pre, l1, h1, vin, l2, h2); return root; &#125; TreeNode *reConstructBinaryTree_recursion(vector&lt;int&gt; pre, int l1, int h1, vector&lt;int&gt; vin, int l2, int h2) &#123; TreeNode *root = new TreeNode(pre[l1]); // 根节点 int i = l2, llen, rlen; while (vin[i] != pre[l1]) &#123; ++i; &#125; // 根节点在中序序列中位置 llen = i - l2; // 左子树长度 rlen = h2 - i; // 右子树长度 if (llen) &#123; root-&gt;left = reConstructBinaryTree_recursion(pre, l1 + 1, l1 + llen, vin, l2, l2 + llen - 1); &#125; // 递归建立左子树 else &#123; root-&gt;left = NULL; &#125; // 左子树为空 if (rlen) &#123; root-&gt;right = reConstructBinaryTree_recursion(pre, h1 - rlen + 1 , h1, vin, h2 - rlen + 1, h2); &#125; // 递归建立右子树 else &#123; root-&gt;right = NULL; &#125; // 右子树为空 return root; // 返回根节点指针 &#125;&#125;;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python [1, -1][x == 0] 写法解释和用处]]></title>
    <url>%2F2019%2F02%2F03%2FPython%20%5B1%2C%20-1%5D%5Bx%20%3D%3D%200%5D%20%E5%86%99%E6%B3%95%E8%A7%A3%E9%87%8A%E5%92%8C%E7%94%A8%E5%A4%84%2F</url>
    <content type="text"><![CDATA[Python [1, -1][x == 0] 写法解释和用处 解释这种写法通俗形式为 [条件为假, 条件为真][判断条件]在 Python 中，布尔型 True 转变为整数等于 1，False 转变为整数等于 0所以条件为真时，返回第二个数，条件为假时，返回第一个数 用处1234if x == 0: a = -1else: a = 1 可以写成这样的形式1a = [1, -1][x == 0]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序递归及非递归实现]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%80%92%E5%BD%92%E5%8F%8A%E9%9D%9E%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[快速排序递归及非递归实现 递归1234567891011121314151617181920212223void QuickSort(int A[], int low, int high) &#123; if (low &lt; high) &#123; int pivotpos = Partition(A, low, high); QuickSort(A, low, pivotpos - 1); QuickSort(A, pivotpos + 1, high); &#125;&#125;int Partition(int A [], int low, int high) &#123; int pivot = A[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123; --high; &#125; A[low] = A[high]; while (low &lt; high &amp;&amp; A [low] &lt;= pivot) &#123; ++low; &#125; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125; 非递归123456789101112131415161718192021222324252627282930313233343536373839void QuickSort(int *array, int left, int right) &#123; stack&lt;int&gt; s; s.push(left); s.push(right); // 后入的 right，所以要先拿 right // 其实就是用栈保存每一个待排序子串的首尾元素下标，下一次 while 循环时取出这个范围，对这段子序列进行 partition 操作 while (!s.empty) &#123; int right = s.top(); s.pop(); int left = s.top(); s.pop(); int index = Partition(array, left, right); if (index-1 &gt; left) &#123; s.push(left); s.push(index - 1); &#125; if (index+1 &lt; right) &#123; s.push(index + 1); s.push(right); &#125; &#125;&#125;int PartSort(int *array,int left,int right) &#123; int key = array[right]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; array[left] &lt;= key) &#123; ++left; &#125; array[right] = array[left]; while (left &lt; right &amp;&amp; array[right] &gt;= key) &#123; --right; &#125; array[left] = array[right]; &#125; array[right] = key; return right;&#125;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树非递归遍历]]></title>
    <url>%2F2019%2F02%2F01%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树非递归遍历 二叉树定义1234typedef struct BiTNode &#123; ElemType data; struct BiTNode *lchild, *rchild;&#125; BiTNode, *BiTree; 先序遍历12345678910111213141516void PreOrder(BiTree T) &#123; InitStack(S); BiTNode *p; p = T; while (p || isEmpty(s)) &#123; if (p) &#123; Push(S, p); visit(p); p = p-&gt;lchild; &#125; else &#123; Pop(S, p); p = p-&gt;rchild; &#125; &#125;&#125; 中序遍历12345678910111213141516void InOrder(BiTree T) &#123; InitStack(S); BiTNode *p; p = T; while (p || isEmpty(s)) &#123; if (p) &#123; Push(S, p); p = p-&gt;lchild; &#125; else &#123; Pop(S, p); visit(p); p = p-&gt;rchild; &#125; &#125;&#125; 后序遍历1234567891011121314151617181920212223242526void PostOrder(BiTree T) &#123; InitStack(S); BiTNode *p; p = T; r = NULL; while (p || isEmpty(s)) &#123; if (p) &#123; Push(S, p); p = p-&gt;lchild; &#125; else &#123; GetTop(S, p); if (p-&gt;rchild &amp;&amp; p-&gt;rchild != r) &#123; p = p-&gt;rchild; Push(S, p); p = p-&gt;lchild; &#125; else &#123; Pop(S, p); visit(p); r = p; p = NULL; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单链表的反转]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[单链表的反转 链表的定义1234typedef struct LinkNode &#123; int val; struct LinkNode *next;&#125; LinkNode; 非递归写法123456789101112131415161718LinkNode *Reverse(LinkNode *head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; LinkNode *pre = head; LinkNode *cur = head-&gt;next; LinkNode *temp = head-&gt;next-&gt;next; while (cur) &#123; temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; &#125; head-&gt;next = NULL; return pre;&#125; 递归写法1234567891011121314LinkNode *Re_Reverse(LinkNode *head) &#123; if (head == NULL || head-&gt;next == NULL) &#123; return head; &#125; // 一直循环到链尾 LinkNode *newHead = Re_Reverse(head-&gt;next); // 翻转链表的指向 head-&gt;next-&gt;next = head; // 记得赋值 NULL，防止链表错乱 head-&gt;next = NULL; // 新链表头永远指向的是原链表的链尾 return newHead;&#125;]]></content>
      <categories>
        <category>DS&amp;A</category>
      </categories>
      <tags>
        <tag>DS&amp;A</tag>
        <tag>C++</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 中的 os.path.dirname(__file__) 的使用]]></title>
    <url>%2F2017%2F07%2F02%2FPython%20%E4%B8%AD%E7%9A%84%20os.path.dirname(__file__)%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Python 中的 os.path.dirname(__file__) 的使用 1. 必须是实际存在的.py文件，如果在命令行执行，则会引发异常1NameError: name &apos;__file__&apos; is not defined 2. 返回的路径在运行的时候如果输入完整的执行的路径 1yxd@yxd-virtual-machine:~/venv$ python /home/yxd/venv/test/test.py 则返回.py文件的全路路径 1/home/yxd/venv/test 如果是非完整路径且不在本目录下执行 1yxd@yxd-virtual-machine:~/venv$ python test/test.py 则返回命令行输入的文件所在路径前面部分 1test 如果是在本目录下运行 1yxd@yxd-virtual-machine:~/venv/test$ python test.py 则返回空 3. 结合os.path.abspath用，效果会更好Python项目的代码中，经常有这样的组合os.path.dirname(os.path.abspath(__file__))或os.path.abspath(os.path.dirname(__file__)) os.path.abspath(__file__)返回的是.py文件的绝对路径 4. os.path.dirname(__file__)的用法总结 不要已命令行的形式使用os.path.dirname(__file__) 结合os.path.abspath()使用]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 日期格式，时间戳之间转换]]></title>
    <url>%2F2017%2F07%2F01%2FPython%20%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%EF%BC%8C%E6%97%B6%E9%97%B4%E6%88%B3%E4%B9%8B%E9%97%B4%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Python 日期格式，时间戳之间转换 获取当前时间戳 方法： 12345import timenow = time.time()print(&apos;now:&apos;, now, &apos;\n&apos;, type(now)) 输出结果： 12now: 1498926743.1411922 &lt;class &apos;float&apos;&gt; 获取当前日期 方法： 12345import datetimedatenow = datetime.datetime.now()print(&apos;datenow:&apos;, datenow, &apos;\n&apos;, type(datenow)) 输出结果： 12datenow: 2017-07-02 00:34:35.272749 &lt;class &apos;datetime.datetime&apos;&gt; 字符串格式更改如a = “2017-07-02 00:34:35”，想改为 a = “2017/07/02 00:34:35” 方法： 1234567import timea = &quot;2013-10-10 23:40:00&quot;timeArray = time.strptime(a, &quot;%Y-%m-%d %H:%M:%S&quot;) # 先转换为时间数组otherStyleTime = time.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;, timeArray) # 转换为其他格式print(&apos;otherStyleTime:&apos;, otherStyleTime) 输出结果： 1otherStyleTime: 2017/07/02 00:34:35 将字符串的时间转换为时间戳 方法： 1234567import timea = &quot;2017-07-02 00:34:35&quot; timeArray = time.strptime(a, &quot;%Y-%m-%d %H:%M:%S&quot;) # 将其转换为时间数组timeStamp = int(time.mktime(timeArray)) # 转换为时间戳print(&apos;timesStamp:&apos;, timeStamp) 输出结果： 1timesStamp: 1498926875 时间戳转换为指定格式日期 方法一： 1234567import timetimeStamp = 1498927046timeArray = time.localtime(timeStamp) # 利用localtime()转换为时间数组otherStyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray) # 格式化为需要的格式print(&apos;otherStyleTime:&apos;, otherStyleTime) 方法二： 1234567import datetimetimeStamp = 1498927046dateArray = datetime.datetime.fromtimestamp(timeStamp)otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)print(&apos;otherStyleTime:&apos;, otherStyleTime) 输出结果： 1otherStyleTime: 2017-07-02 00:37:26 获取当前时间并转换为指定日期格式 方法一： 1234567import timenow = int(time.time()) # 获得当前时间时间戳timeArray = time.localtime(now)StyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray)print(&apos;StyleTime:&apos;, StyleTime) 方法二： 123456import datetimenow = datetime.datetime.now() # 获得当前时间，这是时间数组格式StyleTime = now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 转换为指定的格式print(&apos;StyleTime:&apos;, StyleTime) 输出结果： 1StyleTime: 2017-07-02 00:16:30 获得三天前的时间 方法: 12345678import timeimport datetimethreeDayAgo = (datetime.datetime.now() - datetime.timedelta(days = 3)) # 先获得时间数组格式的日期timeStamp = int(time.mktime(threeDayAgo.timetuple())) # 转换为时间戳threeDayAgo = threeDayAgo.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 转换为其他字符串格式print(&apos;threeDayAgo:&apos;, threeDayAgo) timedelta()的参数有:days, seconds, microseconds, milliseconds, minutes, hours, weeks 输出结果： 1threeDayAgo: 2017-06-29 00:21:04 给定时间戳,计算该时间的几天前时间: 方法: 1234567import datetimetimeStamp = 1498926852dateArray = datetime.datetime.fromtimestamp(timeStamp) # 先转换为datetimethreeDayAgo = dateArray - datetime.timedelta(days=3)print(&apos;threeDayAgo:&apos;, threeDayAgo) 输出结果： 1threeDayAgo: 2017-06-28 16:34:12 参考上面，可以转换为其他的任意格式]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
